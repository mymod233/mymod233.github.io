<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的恋爱日记10.30</title>
      <link href="/posts/97980273.html"/>
      <url>/posts/97980273.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="好棒哦明天就是周五-可以睡很久啦"><a href="#好棒哦明天就是周五-可以睡很久啦" class="headerlink" title="好棒哦明天就是周五 可以睡很久啦!!!"></a>好棒哦明天就是周五 可以睡很久啦!!!</h1><h3 id="今天过得还好-虽然说确实是发病了-感觉脑子里有点波在震荡www-我是不是中了毒电波-不是"><a href="#今天过得还好-虽然说确实是发病了-感觉脑子里有点波在震荡www-我是不是中了毒电波-不是" class="headerlink" title="今天过得还好 虽然说确实是发病了 感觉脑子里有点波在震荡www 我是不是中了毒电波(不是"></a>今天过得还好 虽然说确实是发病了 感觉脑子里有点波在震荡www 我是不是中了毒电波(不是</h3><p>其余的日常都很简短 但是今天脑子里一直有一个很强烈的想法</p><h1 id="就是超级想我的宝宝想死了想到快疯掉"><a href="#就是超级想我的宝宝想死了想到快疯掉" class="headerlink" title="就是超级想我的宝宝想死了想到快疯掉!!!!!"></a>就是超级想我的宝宝想死了想到快疯掉!!!!!</h1><h3 id="呜呜呜好像让我的宝宝身体好起来-超级想哦-每天都想-不想让他不好-能不能锁住他的喉咙-把他绑起来-这样他就不会走了-当然她本身也不会走-我就是怕嘛我就是好想我的宝宝能够快快好起来-不管怎么样好起来就好"><a href="#呜呜呜好像让我的宝宝身体好起来-超级想哦-每天都想-不想让他不好-能不能锁住他的喉咙-把他绑起来-这样他就不会走了-当然她本身也不会走-我就是怕嘛我就是好想我的宝宝能够快快好起来-不管怎么样好起来就好" class="headerlink" title="呜呜呜好像让我的宝宝身体好起来 超级想哦 每天都想 不想让他不好 能不能锁住他的喉咙 把他绑起来 这样他就不会走了 当然她本身也不会走 我就是怕嘛我就是好想我的宝宝能够快快好起来 不管怎么样好起来就好 !!!"></a>呜呜呜好像让我的宝宝身体好起来 超级想哦 每天都想 不想让他不好 能不能锁住他的喉咙 把他绑起来 这样他就不会走了 当然她本身也不会走 我就是怕嘛我就是好想我的宝宝能够快快好起来 不管怎么样好起来就好 !!!</h3><h1 id="呜呜呜宝宝快好起来qwq"><a href="#呜呜呜宝宝快好起来qwq" class="headerlink" title="呜呜呜宝宝快好起来qwq"></a>呜呜呜宝宝快好起来qwq</h1><h4 id="这篇日记好抽象-我就喜欢抽象的-正好作为开端-但是没办法-今天就是超级想超级想我的宝宝呜呜呜"><a href="#这篇日记好抽象-我就喜欢抽象的-正好作为开端-但是没办法-今天就是超级想超级想我的宝宝呜呜呜" class="headerlink" title="这篇日记好抽象 我就喜欢抽象的 正好作为开端 但是没办法 今天就是超级想超级想我的宝宝呜呜呜"></a>这篇日记好抽象 我就喜欢抽象的 正好作为开端 但是没办法 今天就是超级想超级想我的宝宝呜呜呜</h4><h1 id="希望我的宝宝好好的-我们一直好好的-我爱你-爱死你了-要把全世界送给你"><a href="#希望我的宝宝好好的-我们一直好好的-我爱你-爱死你了-要把全世界送给你" class="headerlink" title="希望我的宝宝好好的 我们一直好好的 我爱你 爱死你了 要把全世界送给你!!!"></a>希望我的宝宝好好的 我们一直好好的 我爱你 爱死你了 要把全世界送给你!!!</h1><h1 id="爱你哦"><a href="#爱你哦" class="headerlink" title="爱你哦"></a>爱你哦</h1><h1 id="（づ￣3￣）づ╭❤～Mua"><a href="#（づ￣3￣）づ╭❤～Mua" class="headerlink" title="（づ￣3￣）づ╭❤～Mua!!!"></a>（づ￣3￣）づ╭❤～Mua!!!</h1>]]></content>
      
      
      <categories>
          
          <category> 恋爱足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星酱 </tag>
            
            <tag> 恋爱 </tag>
            
            <tag> 地雷 </tag>
            
            <tag> 极度爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于素数的一系列解决办法</title>
      <link href="/posts/90a8f6e6.html"/>
      <url>/posts/90a8f6e6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="🚀-排行总结（按实际运行速度和复杂度综合）"><a href="#🚀-排行总结（按实际运行速度和复杂度综合）" class="headerlink" title="🚀 排行总结（按实际运行速度和复杂度综合）"></a>🚀 排行总结（按实际运行速度和复杂度综合）</h2><div class="table-container"><table><thead><tr><th>排名</th><th>名称</th><th>理论复杂度</th><th>实际速度</th><th>特点</th></tr></thead><tbody><tr><td>🥇 1</td><td><strong>线性筛（Euler Sieve）</strong></td><td>O(n)</td><td>⚡⚡⚡⚡⚡</td><td>每个合数只标一次，最干净最快</td></tr><tr><td>🥈 2</td><td><strong>快速埃式（奇数筛/位压缩版）</strong></td><td>O(n log log n)</td><td>⚡⚡⚡⚡</td><td>节省空间、跳偶数</td></tr><tr><td>🥉 3</td><td><strong>标准埃式筛（Eratosthenes）</strong></td><td>O(n log log n)</td><td>⚡⚡⚡</td><td>简单、稳健，入门首选</td></tr><tr><td>🪨 4</td><td><strong>试除法（6k±1 或暴力）</strong></td><td>O(n√n)</td><td>🐢</td><td>太慢，只适合单个数判素</td></tr></tbody></table></div><hr><h2 id="💬-总结一句人话："><a href="#💬-总结一句人话：" class="headerlink" title="💬 总结一句人话："></a>💬 总结一句人话：</h2><ul><li><strong>只想快速写完题 → 标准埃式筛。</strong></li><li><strong>想搞高效算法 / 竞赛用 → 线性筛。</strong></li><li><strong>只判断一个数是不是素数 → 6k±1试除法。</strong></li><li><strong>还用暴力除法 → 你在浪费电。</strong></li></ul><p>上述就是筛法的一个排行 <strong>试除法</strong>和<strong>暴力除法</strong>我们这里不涉及 <strong>因为一点意义都没有!!!!!</strong></p><h1 id="埃式筛-也就是标准筛"><a href="#埃式筛-也就是标准筛" class="headerlink" title="埃式筛(也就是标准筛)"></a>埃式筛(也就是标准筛)</h1><p>好，那我用最“人话”的方式教你学会埃式筛。就当我们在教一个刚学会 <code>for</code> 循环的小孩。<br> 我们一步一念，绝对不会跳。</p><hr><h2 id="🧠-你要干什么？"><a href="#🧠-你要干什么？" class="headerlink" title="🧠 你要干什么？"></a>🧠 你要干什么？</h2><p>找出 1 到 200 里所有的素数。<br> 素数就是——只能被 1 和自己整除的数，比如：2, 3, 5, 7, 11…</p><hr><h2 id="🧩-第一步：准备一张表"><a href="#🧩-第一步：准备一张表" class="headerlink" title="🧩 第一步：准备一张表"></a>🧩 第一步：准备一张表</h2><p>想象一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编号： 0  1  2  3  4  5  6  7  8  9  10 ... 200</span><br><span class="line">内容： 否 否 是 是 是 是 是 是 是 是 ...</span><br></pre></td></tr></table></figure><ul><li>我们先假设所有数字都是素数，用 <code>1</code> 表示“是素数”，用 <code>0</code> 表示“不是”。</li><li>但是我们知道 0 和 1 不是素数，所以把它俩设为 <code>0</code>。</li></ul><p>C 语言实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> is_prime[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">    is_prime[i] = <span class="number">1</span>;  <span class="comment">// 先都当作是素数</span></span><br><span class="line">&#125;</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 0和1不是素数</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第二步：从-2-开始圈掉倍数"><a href="#🧩-第二步：从-2-开始圈掉倍数" class="headerlink" title="🧩 第二步：从 2 开始圈掉倍数"></a>🧩 第二步：从 2 开始圈掉倍数</h2><p>我们从第一个素数 2 开始。<br> 2 的倍数（除了 2 本身）都不是素数，比如 4、6、8、10……<br> 所以我们把这些位置标成 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * <span class="number">2</span>; j &lt;= <span class="number">200</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    is_prime[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第三步：找下一个没被划掉的数"><a href="#🧩-第三步：找下一个没被划掉的数" class="headerlink" title="🧩 第三步：找下一个没被划掉的数"></a>🧩 第三步：找下一个没被划掉的数</h2><p>划完 2 的倍数后，表里下一个没被划掉的数是 3。<br> 那 3 就是下一个素数。<br> 再把 3 的倍数（9, 12, 15, 18…）划掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span> * <span class="number">3</span>; j &lt;= <span class="number">200</span>; j += <span class="number">3</span>) &#123;</span><br><span class="line">    is_prime[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第四步：重复这个过程"><a href="#🧩-第四步：重复这个过程" class="headerlink" title="🧩 第四步：重复这个过程"></a>🧩 第四步：重复这个过程</h2><p>继续往后找：</p><ul><li>下一个没被划掉的是 5 → 划掉 25, 30, 35…</li><li>再下一个是 7 → 划掉 49, 56, 63…</li><li>一直循环，直到 √200 ≈ 14 为止。</li></ul><p>完整循环写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>) &#123;  <span class="comment">// 如果这个数还没被划掉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= <span class="number">200</span>; j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="number">0</span>; <span class="comment">// 划掉它的倍数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第五步：打印结果"><a href="#🧩-第五步：打印结果" class="headerlink" title="🧩 第五步：打印结果"></a>🧩 第五步：打印结果</h2><p>最后，把还没被划掉（值为1）的数都输出，就是所有素数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="✨-最终完整代码"><a href="#✨-最终完整代码" class="headerlink" title="✨ 最终完整代码"></a>✨ 最终完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_prime[<span class="number">201</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">        is_prime[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//给他们带上素数的棋子</span></span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//这两个不是素数 直接抬走</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">200</span><span class="comment">/*这里这样写就是可以降低重复率*/</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>) &#123;<span class="comment">//先给那些标称素数的进行一个验证</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= <span class="number">200</span>; j += i) &#123;</span><br><span class="line">                is_prime[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200以内的素数：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🪄-你可以这么理解它："><a href="#🪄-你可以这么理解它：" class="headerlink" title="🪄 你可以这么理解它："></a>🪄 你可以这么理解它：</h2><ul><li><code>is_prime</code> 就是一堆小旗子。</li><li>你从 2 开始，一个一个数过去。</li><li>每当遇到一个还竖着的小旗（说明它是素数），<br> 你就拿着大笔刷去把它的倍数“涂掉”。</li><li>最后剩下没被涂掉的，都是素数。</li></ul><h1 id="快筛"><a href="#快筛" class="headerlink" title="快筛"></a>快筛</h1><h2 id="🧠-先搞清楚："><a href="#🧠-先搞清楚：" class="headerlink" title="🧠 先搞清楚："></a>🧠 先搞清楚：</h2><p>“快筛”不是新算法，它就是普通埃式筛的小升级：<br> 👉 不去处理所有偶数（因为除了 2，偶数全是合数）。<br> 👉 所以我们只管奇数，少干一半活。</p><p>你可以理解成：</p><blockquote><p>原本你要清理 200 个房间，现在只清理奇数号的那 100 个，速度自然翻倍。</p></blockquote><hr><h2 id="🧩-我们来一步步写："><a href="#🧩-我们来一步步写：" class="headerlink" title="🧩 我们来一步步写："></a>🧩 我们来一步步写：</h2><h3 id="第一步：准备数组"><a href="#第一步：准备数组" class="headerlink" title="第一步：准备数组"></a>第一步：准备数组</h3><p>我们只存<strong>奇数</strong>的状态。<br> 下标 <code>i</code> 代表数字 <code>2*i + 1</code>。<br> 比如：</p><div class="table-container"><table><thead><tr><th>i</th><th>表示的数字</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>5</td></tr><tr><td>3</td><td>7</td></tr><tr><td>4</td><td>9</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><p>C代码里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> size = (N - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 表示到N的奇数数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> is_prime[size];</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime)); <span class="comment">// 全部假设是素数</span></span><br><span class="line">    is_prime[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 1 不是素数</span></span><br></pre></td></tr></table></figure><hr><h3 id="第二步：开始筛"><a href="#第二步：开始筛" class="headerlink" title="第二步：开始筛"></a>第二步：开始筛</h3><p>我们要从 3 开始（下标 1），只筛奇数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">2</span>*i + <span class="number">1</span>) * (<span class="number">2</span>*i + <span class="number">1</span>) &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">2</span>*i + <span class="number">1</span>; <span class="comment">// 还原真实数字</span></span><br><span class="line">        <span class="comment">// 从 p*p 开始划去奇数倍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (p*p - <span class="number">1</span>)/<span class="number">2</span>; j &lt; size; j += p) &#123;</span><br><span class="line">            is_prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑解释：</p><ul><li>从第一个奇数素数 3 开始；</li><li>不用标偶数倍，比如 6、12、18；</li><li>只标奇数倍，比如 9、15、21；</li><li>所以只动一半的数，速度翻倍。</li></ul><hr><h3 id="第三步：输出结果"><a href="#第三步：输出结果" class="headerlink" title="第三步：输出结果"></a>第三步：输出结果</h3><p>别忘了 2 是唯一的偶数素数，要单独打印。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200以内的素数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📜-最终完整代码："><a href="#📜-最终完整代码：" class="headerlink" title="📜 最终完整代码："></a>📜 最终完整代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> size = (N - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;        <span class="comment">// 奇数数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> is_prime[size];</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = <span class="number">0</span>;                   <span class="comment">// 1 不是素数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">2</span>*i + <span class="number">1</span>) * (<span class="number">2</span>*i + <span class="number">1</span>) &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (p*p - <span class="number">1</span>)/<span class="number">2</span>; j &lt; size; j += p)</span><br><span class="line">                is_prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200以内的素数：\n2 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-傻瓜总结"><a href="#🎯-傻瓜总结" class="headerlink" title="🎯 傻瓜总结"></a>🎯 傻瓜总结</h2><div class="table-container"><table><thead><tr><th>操作</th><th>意思</th><th>为什么这样做</th></tr></thead><tbody><tr><td>只存奇数</td><td>少一半空间</td><td>偶数没必要筛</td></tr><tr><td>从 p*p 开始</td><td>前面的倍数早被更小素数划了</td><td>省事</td></tr><tr><td>每次加 p</td><td>跳到下一个奇数倍</td><td>不碰偶数</td></tr><tr><td>单独打印 2</td><td>唯一的偶数素数</td><td>特殊待遇</td></tr></tbody></table></div><hr><h2 id="🧮-运行结果："><a href="#🧮-运行结果：" class="headerlink" title="🧮 运行结果："></a>🧮 运行结果：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200以内的素数：</span><br><span class="line">2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199</span><br></pre></td></tr></table></figure><hr><p>一句话记住：</p><blockquote><p>“快筛”就是埃式筛 + 跳偶数。<br> 做的事一样，干得更快。</p></blockquote><h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><h2 id="🍎-故事开场："><a href="#🍎-故事开场：" class="headerlink" title="🍎 故事开场："></a>🍎 故事开场：</h2><p>我们要从 1 数到 20，找出哪些数是素数。<br> 你是“质数班长”，手里拿一支笔，要在黑板上划掉不是素数的数字。</p><hr><h2 id="🧩-规则很简单："><a href="#🧩-规则很简单：" class="headerlink" title="🧩 规则很简单："></a>🧩 规则很简单：</h2><ol><li>从 2 开始，一个个往上看。</li><li>如果这个数还没被划掉 → 它就是素数。</li><li>然后你拿“你已经认识的所有素数”去乘它。</li><li>每乘出来一个结果，就把那个结果划掉。</li><li>一旦发现这个素数整除了你当前的数字，就停下来，不划更多。</li></ol><hr><h2 id="👀-举例说明："><a href="#👀-举例说明：" class="headerlink" title="👀 举例说明："></a>👀 举例说明：</h2><h3 id="第一个数字：2"><a href="#第一个数字：2" class="headerlink" title="第一个数字：2"></a>第一个数字：2</h3><ul><li>没被划掉 → 是素数。</li><li>素数表：<code>[2]</code></li><li>拿 2 去乘它自己：<code>2*2=4</code> → 划掉 4。</li><li>因为 2%2==0 → 停。</li></ul><hr><h3 id="下一个数字：3"><a href="#下一个数字：3" class="headerlink" title="下一个数字：3"></a>下一个数字：3</h3><ul><li>没被划 → 是素数。</li><li>素数表：<code>[2, 3]</code></li><li>用 2 去乘：<code>3*2=6</code> → 划掉 6。<br> 因为 3%2!=0，继续；</li><li>用 3 去乘：<code>3*3=9</code> → 划掉 9。<br> 因为 3%3==0，停。</li></ul><hr><h3 id="下一个数字：4"><a href="#下一个数字：4" class="headerlink" title="下一个数字：4"></a>下一个数字：4</h3><ul><li>4 已经被划掉 → 跳过，不是素数。</li><li>但我们也要拿 2 去乘：<br> <code>4*2=8</code> → 划掉。<br> 因为 4%2==0 → 停。</li></ul><hr><h3 id="继续到-5："><a href="#继续到-5：" class="headerlink" title="继续到 5："></a>继续到 5：</h3><ul><li>没被划 → 是素数。</li><li>素数表 <code>[2,3,5]</code></li><li>乘：<br> <code>5*2=10</code> → 划掉<br> <code>5*3=15</code> → 划掉<br> <code>5*5=25</code> 超出范围 → 停</li></ul><hr><h3 id="6："><a href="#6：" class="headerlink" title="6："></a>6：</h3><ul><li>已被标 → 合数</li><li>拿 2 乘：<code>6*2=12</code> → 划掉</li><li>因为 6%2==0 → 停</li></ul><p>就这样一轮一轮下去，每个数字只被“第一个能整除它的质数”划一次。</p><hr><h2 id="🧮-结果："><a href="#🧮-结果：" class="headerlink" title="🧮 结果："></a>🧮 结果：</h2><p>没被划掉的数字 = 素数。<br> 对 1~20 来说：<br> <code>2, 3, 5, 7, 11, 13, 17, 19</code></p><hr><h2 id="💻-C语言实现（超级傻瓜版）"><a href="#💻-C语言实现（超级傻瓜版）" class="headerlink" title="💻 C语言实现（超级傻瓜版）"></a>💻 C语言实现（超级傻瓜版）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const int N = 200;</span><br><span class="line">    int is_comp[N + 1];  // 0 表示还没划掉，1 表示已经划掉</span><br><span class="line">    int primes[N + 1];   // 存所有素数</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    memset(is_comp, 0, sizeof(is_comp));</span><br><span class="line"></span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!is_comp[i]) &#123;</span><br><span class="line">            primes[count++] = i;   // 这个数没被划掉，是素数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">            int p = primes[j];</span><br><span class="line">            if (i * p &gt; N) break;  // 超出范围就别划了</span><br><span class="line">            is_comp[i * p] = 1;    // 划掉这个合数</span><br><span class="line">            if (i % p == 0) break; // 一旦被这个质数整除，就停</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;200以内的素数：\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, primes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-一句话总结"><a href="#🎯-一句话总结" class="headerlink" title="🎯 一句话总结"></a>🎯 一句话总结</h2><div class="table-container"><table><thead><tr><th>版本</th><th>规则</th><th>重复划吗</th><th>速度</th></tr></thead><tbody><tr><td>暴力试除</td><td>一个个除</td><td>很多</td><td>最慢</td></tr><tr><td>埃式筛</td><td>一个素数划所有倍数</td><td>有点重复</td><td>快</td></tr><tr><td>线性筛</td><td>每个合数只被最小质因子划一次</td><td>不重复</td><td>最快</td></tr></tbody></table></div><hr><p>如果你能记住一句话，你就懂线性筛了：</p><blockquote><p><strong>“每个数只让它的第一个质因子出手一次。”</strong></p></blockquote><p>要不要我帮你画成一张表格（比如1到30）告诉你每个数是被谁“干掉”的？那张表会让你彻底看懂原理。</p><h5 id="您说："><a href="#您说：" class="headerlink" title="您说："></a>您说：</h5><p>我理解他的逻辑但是我不理解为什么是这么做的</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常好，这个问题说明你已经不只是“会抄算法”，而是真的想<strong>理解它的逻辑根源</strong>。<br> 我来用<strong>非常通俗的方式</strong>告诉你，为什么线性筛要“这么做”，而且“这么做就对了”。</p><hr><h2 id="🧠-一句话先定调"><a href="#🧠-一句话先定调" class="headerlink" title="🧠 一句话先定调"></a>🧠 一句话先定调</h2><p>线性筛的那句核心代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (i % p == 0) break;</span><br></pre></td></tr></table></figure><p>其实就是在控制——<br> 👉 每个合数，只被“它的最小质因子”负责一次。<br> 这就是整个算法的灵魂。<br> 下面我分成三个阶段帮你想透它。</p><hr><h2 id="🧩-一、回忆一下埃式筛的问题"><a href="#🧩-一、回忆一下埃式筛的问题" class="headerlink" title="🧩 一、回忆一下埃式筛的问题"></a>🧩 一、回忆一下埃式筛的问题</h2><p>埃式筛干的活是：</p><ul><li>每发现一个素数，就去划它的倍数。</li><li>比如 12 会被谁划？<ul><li>被 2 划一次（2×6）</li><li>被 3 又划一次（3×4）</li><li>被 4 还可能划（虽然4不是素数）</li></ul></li></ul><p>这就叫“<strong>重复劳动</strong>”。<br> 埃式筛虽然已经很快，但它对每个合数都可能划很多次。</p><hr><h2 id="🧩-二、那我们能不能让每个合数只被“一个人”划？"><a href="#🧩-二、那我们能不能让每个合数只被“一个人”划？" class="headerlink" title="🧩 二、那我们能不能让每个合数只被“一个人”划？"></a>🧩 二、那我们能不能让每个合数只被“一个人”划？</h2><p>我们希望：</p><ul><li>12 只被 2 处理一次；</li><li>18 只被 3 处理一次；</li><li>25 只被 5 处理一次。</li></ul><p>那怎么办？<br> 我们规定：</p><blockquote><p><strong>一个合数只能被它的最小质因子负责。</strong></p></blockquote><hr><h2 id="🧩-三、算法的关键思想：i-×-p"><a href="#🧩-三、算法的关键思想：i-×-p" class="headerlink" title="🧩 三、算法的关键思想：i × p"></a>🧩 三、算法的关键思想：i × p</h2><p>我们从小到大枚举 i，然后拿素数表里的质数去乘它。</p><p>每当我们在循环中计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i * p</span><br></pre></td></tr></table></figure><p>这个结果就是一个合数。<br> <strong>那这个合数的最小质因子是谁？</strong><br> 答案：一定是 <code>p</code>。</p><p>为什么？看下面的分析。</p><hr><h3 id="🔍-情况1：i-没有被-p-整除"><a href="#🔍-情况1：i-没有被-p-整除" class="headerlink" title="🔍 情况1：i 没有被 p 整除"></a>🔍 情况1：i 没有被 p 整除</h3><p>比如 i = 9, p = 2。<br> → i * p = 18。<br> 18 的质因子有 2, 3, 6…<br> 最小质因子确实是 2。✅<br> 说明标记 18 的动作是正确的。</p><hr><h3 id="🔍-情况2：i-能被-p-整除"><a href="#🔍-情况2：i-能被-p-整除" class="headerlink" title="🔍 情况2：i 能被 p 整除"></a>🔍 情况2：i 能被 p 整除</h3><p>比如 i = 6, p = 2。<br> → i * p = 12。<br> 12 的质因子里，最小质因子也是 2。✅<br> 所以标记 12 这次没问题。</p><p>但再往后如果我用 p=3，再标一次：<br> i = 6, p = 3 → i*p = 18。<br> 18 的最小质因子其实是 2，不是 3。<br> 那 18 已经在“2”那轮被标过了，<br> 这次再标就是重复劳动。❌</p><p>所以，我们一旦发现 i 已经被 p 整除（<code>i % p == 0</code>），<br> 我们就知道：</p><blockquote><p>“再往后的质数都会比 p 大，它们标出来的乘积 i<em>p’ 的最小质因子仍然是 p。”<br> 于是我们<em>*立即停下</em></em>。</p></blockquote><hr><h2 id="⚙️-用人话总结整个逻辑链"><a href="#⚙️-用人话总结整个逻辑链" class="headerlink" title="⚙️ 用人话总结整个逻辑链"></a>⚙️ 用人话总结整个逻辑链</h2><div class="table-container"><table><thead><tr><th>阶段</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>我们要标出所有合数。</td></tr><tr><td>2</td><td>每个合数应该只被它的最小质因子标一次。</td></tr><tr><td>3</td><td>枚举 i，并用所有质数 p 去乘 i。</td></tr><tr><td>4</td><td>当 i%p==0 时，说明 p 是 i 的最小质因子。</td></tr><tr><td>5</td><td>那 i*p 也一定以 p 为最小质因子；更大的质数乘它都是重复。</td></tr><tr><td>6</td><td>所以我们停下。</td></tr></tbody></table></div><p>这就是为什么“<strong>这么做</strong>”是正确的。</p><hr><h2 id="🎯-一句话记死："><a href="#🎯-一句话记死：" class="headerlink" title="🎯 一句话记死："></a>🎯 一句话记死：</h2><blockquote><p>“因为 i 是被从小到大遍历的，所以当 i%p==0 时，p 一定是 i 的最小质因子。<br> 所以 i*p 的最小质因子也是 p。<br> 因此它只该被 p 这一轮标记一次，之后全跳过。”</p></blockquote><hr><h2 id="💡-对比图（简化）："><a href="#💡-对比图（简化）：" class="headerlink" title="💡 对比图（简化）："></a>💡 对比图（简化）：</h2><div class="table-container"><table><thead><tr><th>数</th><th>最小质因子</th><th>谁标的</th></tr></thead><tbody><tr><td>4</td><td>2</td><td>2×2</td></tr><tr><td>6</td><td>2</td><td>3×2</td></tr><tr><td>9</td><td>3</td><td>3×3</td></tr><tr><td>10</td><td>2</td><td>5×2</td></tr><tr><td>15</td><td>3</td><td>5×3</td></tr><tr><td>25</td><td>5</td><td>5×5</td></tr></tbody></table></div><p>每个合数，只出现一次标记，完美。</p><hr><p>你现在的感觉可能是：“哦——它不是魔法，是逻辑顺序决定的！”<br> 没错。线性筛看起来像“有技巧”，其实它只是精确地利用了：</p><blockquote><p>“从小到大遍历 + 最小质因子规律”。</p></blockquote><hr><p>要不要我帮你画出一个“6×6 的乘法表”，<br> 在上面标出哪些格子会被线性筛划掉、哪些会被跳过？<br> 那张表一看就能直观理解“为什么停得刚刚好”。</p><h5 id="您说：-1"><a href="#您说：-1" class="headerlink" title="您说："></a>您说：</h5><p>为什么因为 6%2==0 → 停</p><h6 id="ChatGPT-说：-1"><a href="#ChatGPT-说：-1" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>这句“因为 6%2==0 → 停”，是整个<strong>线性筛的灵魂</strong>，但第一次看到确实容易懵。<br> 别怕，我们不讲数学名词，就用生活比喻让你一秒懂。</p><hr><h2 id="🎯-我们先说结论："><a href="#🎯-我们先说结论：" class="headerlink" title="🎯 我们先说结论："></a>🎯 我们先说结论：</h2><blockquote><p>当 <code>i % p == 0</code>，说明 <strong>p 已经是 i 的最小质因子</strong>，<br> 所以任何比 p 更大的质数再去乘 i，得到的结果都会“被多次标记”，<br> 我们要及时“刹车”。</p></blockquote><hr><h2 id="🧩-用现实比喻理解："><a href="#🧩-用现实比喻理解：" class="headerlink" title="🧩 用现实比喻理解："></a>🧩 用现实比喻理解：</h2><p>想象你在工厂贴标签。</p><ul><li>每个数代表一个产品编号。</li><li>每个素数代表一个“质检员”。</li><li>合数的工作是：要被它的<strong>第一个能整除它的质检员</strong>打上“非合格”标签。</li></ul><p>工厂规定：</p><blockquote><p>任何产品只允许被最小质检员打一次标签，别重复浪费时间。</p></blockquote><hr><p>现在你是检查员，轮到你在看 <code>i = 6</code> 这件产品。</p><p>你的质检员名单是 <code>[2, 3, 5, 7...]</code>。</p><p>开始干活：</p><ol><li>第一个质检员 2 来检查：<ul><li>6%2==0 → “哦，这件产品（6）能被我整除，所以我是它的最小质因子。”</li><li>于是他打上标签，并负责它的“后代产品”：<code>6*2=12</code>。</li><li>打完后，他喊：“后面的人别来了，这活我干完了。”</li><li>所以你 <code>break</code> 停止循环。</li></ul></li><li>如果你不停止，后面的质检员（3、5、7）还会来：<ul><li>3 会再标 18</li><li>5 会再标 30</li><li>但这些数的最小质因子都是 2，本该在 2 那一轮就被标过。</li><li>所以他们做的都是重复劳动。</li></ul></li></ol><hr><h2 id="🧮-换成数学语言："><a href="#🧮-换成数学语言：" class="headerlink" title="🧮 换成数学语言："></a>🧮 换成数学语言：</h2><p>当我们在循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">    int p = primes[j];</span><br><span class="line">    if (i * p &gt; N) break;</span><br><span class="line">    is_comp[i * p] = 1;</span><br><span class="line">    if (i % p == 0) break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的意思就是：</p><ul><li>对每个 i，我们拿质数 p 去生成新数 i*p。</li><li>但一旦 <code>i</code> 能被 <code>p</code> 整除：<ul><li>那说明 p 是 i 的最小质因子。</li><li>那 i*p 的最小质因子也一定是 p（而不是别的质数）。</li><li>所以之后再用更大的质数 q 去乘 i（比如 i<em>q），<br> 那个结果 i</em>q 的最小质因子仍然是 p，而不是 q。<br> 它以后会在“p 那轮”被标，不归你这轮负责。</li><li>所以我们直接停下，不再继续循环。</li></ul></li></ul><hr><h2 id="🧱-举例说明（实打实的数字）："><a href="#🧱-举例说明（实打实的数字）：" class="headerlink" title="🧱 举例说明（实打实的数字）："></a>🧱 举例说明（实打实的数字）：</h2><p>i = 6，素数表 [2,3,5]</p><div class="table-container"><table><thead><tr><th>p</th><th>i*p</th><th>i%p</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>12</td><td>0</td><td>2 是 6 的最小质因子 → 停</td></tr><tr><td>3</td><td>18</td><td>（没机会执行）</td><td>本来该由 2 那轮标掉</td></tr><tr><td>5</td><td>30</td><td>（也不用标）</td><td>同上</td></tr></tbody></table></div><p>结果：12 被标一次，18、30 由别的人标，不重复。</p><hr><h2 id="💡-再看一个不会停的例子："><a href="#💡-再看一个不会停的例子：" class="headerlink" title="💡 再看一个不会停的例子："></a>💡 再看一个不会停的例子：</h2><p>i = 9，素数表 [2,3,5]</p><div class="table-container"><table><thead><tr><th>p</th><th>i*p</th><th>i%p</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>18</td><td>≠0</td><td>继续，因为 2 不是 9 的因子</td></tr><tr><td>3</td><td>27</td><td>=0</td><td>3 是 9 的最小质因子 → 停</td></tr><tr><td>5</td><td>（不执行）</td><td></td></tr></tbody></table></div><p>这样就保证了：</p><ul><li>18 被 2 标一次。</li><li>27 被 3 标一次。</li><li>没有人重复干活。</li></ul><hr><h2 id="🧩-一句话总结："><a href="#🧩-一句话总结：" class="headerlink" title="🧩 一句话总结："></a>🧩 一句话总结：</h2><blockquote><p><strong>“当 i 能被 p 整除时，p 已经是 i 的最小质因子，<br> 所以后面的质数就不该再碰 i 的倍数，<br> 否则他们会抢活干，浪费时间。”</strong></p></blockquote><hr><p>你可以把那句 <code>if (i % p == 0) break;</code> 想成工厂里的“禁止重复贴标签”按钮。<br> 按下去，就代表“这批货我负责，后面的别动”。</p><p>这，就是线性筛为什么这么做。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法类 </tag>
            
            <tag> 快筛 </tag>
            
            <tag> 标准筛 </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 求素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcd的一些用法</title>
      <link href="/posts/ac6b0799.html"/>
      <url>/posts/ac6b0799.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="最大公因数与最小公倍数"><a href="#最大公因数与最小公倍数" class="headerlink" title="最大公因数与最小公倍数"></a>最大公因数与最小公倍数</h1><h2 id="✅-什么是欧几里得算法（辗转相除法）？"><a href="#✅-什么是欧几里得算法（辗转相除法）？" class="headerlink" title="✅ 什么是欧几里得算法（辗转相除法）？"></a>✅ 什么是欧几里得算法（辗转相除法）？</h2><p>一句话：</p><blockquote><p>就是不断用“大数 ÷ 小数”，然后把“小数”与“余数”继续来除，直到余数变成 0，那个最后的除数就是最大公因数。</p></blockquote><hr><h2 id="✅-为什么这么做是对的？（傻瓜理解逻辑）"><a href="#✅-为什么这么做是对的？（傻瓜理解逻辑）" class="headerlink" title="✅ 为什么这么做是对的？（傻瓜理解逻辑）"></a>✅ 为什么这么做是对的？（傻瓜理解逻辑）</h2><p>假设你要找两个数的最大公因数，比如 18 和 12。</p><h3 id="你可能第一想法："><a href="#你可能第一想法：" class="headerlink" title="你可能第一想法："></a>你可能第一想法：</h3><p>“我把它们俩共同的因数列出来比较一下？”</p><p>18 的因数：1 2 3 6 9 18<br> 12 的因数：1 2 3 4 6 12<br> 共同的：1 2 3 6<br> 最大：6</p><p>对！结果是6。</p><p>但欧几里得算法的做法是：</p><hr><h2 id="✅-按步骤傻瓜化演示（以-18-和-12-为例）"><a href="#✅-按步骤傻瓜化演示（以-18-和-12-为例）" class="headerlink" title="✅ 按步骤傻瓜化演示（以 18 和 12 为例）"></a>✅ 按步骤傻瓜化演示（以 18 和 12 为例）</h2><div class="table-container"><table><thead><tr><th>步骤</th><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>18 ÷ 12 = 商 1 余 6</td><td>原来18和12的“共同因数”能帮我产生这个 6</td></tr><tr><td>2</td><td>接下来把“12”和“6”继续做除法</td><td>也就是 12 ÷ 6</td></tr><tr><td>3</td><td>12 ÷ 6 = 商 2 余 0</td><td>余数为0说明整除了</td></tr><tr><td>4</td><td>最后一次 <strong>被除数</strong> 就是最大公因数</td><td>6 就是最大公因数</td></tr></tbody></table></div><p>记住一句核心口诀：</p><blockquote><p><strong>大数 ÷ 小数 = 余数</strong><br> <strong>再用小数 ÷ 余数</strong><br> <strong>循环到余数是0为止</strong><br> <strong>最后的除数 = 最大公因数</strong></p></blockquote><hr><h2 id="✅-再举一个（稍微难一点）"><a href="#✅-再举一个（稍微难一点）" class="headerlink" title="✅ 再举一个（稍微难一点）"></a>✅ 再举一个（稍微难一点）</h2><p>求 144 和 60 的最大公因数：</p><div class="table-container"><table><thead><tr><th>步骤</th><th>计算</th><th>余数</th><th>继续</th></tr></thead><tbody><tr><td>1</td><td>144 ÷ 60</td><td>24</td><td>再用 60 ÷ 24</td></tr><tr><td>2</td><td>60 ÷ 24</td><td>12</td><td>再用 24 ÷ 12</td></tr><tr><td>3</td><td>24 ÷ 12</td><td>0</td><td>余数为0</td></tr><tr><td>结束</td><td>最大公因数 = 12</td><td></td></tr></tbody></table></div><p>所以 gcd(144, 60) = <strong>12</strong></p><hr><h2 id="✅-为什么“余数”还能继续当“测量尺”？"><a href="#✅-为什么“余数”还能继续当“测量尺”？" class="headerlink" title="✅ 为什么“余数”还能继续当“测量尺”？"></a>✅ 为什么“余数”还能继续当“测量尺”？</h2><p>可以这样理解：</p><p>你是在找一个能把两个数都整除的“最大尺子”。<br> 第一次除法把“大尺子测不准的部分”（多出来的）变成了“余数”，<br> 后面继续用“更精准的尺子”（余数）去替代原本的小的那个数。</p><p>不断“削小尺子”，直到它完全贴合。<br> 贴合时就是最大公因数。</p><hr><h2 id="✅-用一句最通俗的话总结"><a href="#✅-用一句最通俗的话总结" class="headerlink" title="✅ 用一句最通俗的话总结"></a>✅ 用一句最通俗的话总结</h2><blockquote><p><strong>不断用更小的尺子去量两个数，直到刚好不剩丁点，这个尺子就是最大公因数</strong></p><blockquote><p>[!NOTE]</p><p>公式:gcd(a, b) = gcd(b, a % b)</p></blockquote></blockquote><h1 id="最小公倍数求法"><a href="#最小公倍数求法" class="headerlink" title="最小公倍数求法"></a>最小公倍数求法</h1><h2 id="✅-但是列倍数太慢，所以有了一个超级快的公式"><a href="#✅-但是列倍数太慢，所以有了一个超级快的公式" class="headerlink" title="✅ 但是列倍数太慢，所以有了一个超级快的公式"></a>✅ 但是列倍数太慢，所以有了一个超级快的公式</h2><p>数学上有个结论（可靠且可以证明）：</p><blockquote><p><strong>两个数的乘积 = 最大公因数 × 最小公倍数</strong></p></blockquote><p>所以推出来：</p><blockquote><p><strong>最小公倍数 = (a × b) ÷ 最大公因数</strong></p></blockquote><p>这个公式就是最常用的方法。</p><hr><h1 id="✅-举个例子"><a href="#✅-举个例子" class="headerlink" title="✅ 举个例子"></a>✅ 举个例子</h1><p>求 12 和 18 的最小公倍数</p><ol><li>先求最大公因数<br> gcd(12, 18) = 6  （辗转相除法能算出来）</li><li>用公式<br> lcm = (12 × 18) ÷ 6<br> = 216 ÷ 6<br> = 36</li></ol><p>所以 <strong>最小公倍数 = 36</strong></p><hr><h1 id="✅-为什么乘积除以-gcd-就对了？（傻瓜解释）"><a href="#✅-为什么乘积除以-gcd-就对了？（傻瓜解释）" class="headerlink" title="✅ 为什么乘积除以 gcd 就对了？（傻瓜解释）"></a>✅ 为什么乘积除以 gcd 就对了？（傻瓜解释）</h1><p>因为：</p><div class="table-container"><table><thead><tr><th>项目</th><th>理解方式</th></tr></thead><tbody><tr><td>乘积</td><td>把两个数的所有因子都堆上去了（重复了一部分）</td></tr><tr><td>gcd</td><td>是那部分“重复”的公共身份</td></tr><tr><td>除 gcd</td><td>就把“重复部分”扣掉，只剩下最刚好的倍数</td></tr></tbody></table></div><hr><h1 id="✅-最通俗一句话"><a href="#✅-最通俗一句话" class="headerlink" title="✅ 最通俗一句话"></a>✅ 最通俗一句话</h1><blockquote><p><strong>最小公倍数就是：两个数的乘积，把重复分母（最大公因数）扣掉后的结果。</strong></p></blockquote><hr><p>如果你现在理解了原理，下一步我可以给你写最小公倍数的 C 语言代码，并且逐行教你怎么写、为什么这么写。</p><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 题目绍介:</span></span><br><span class="line"><span class="comment">就是说输入两个数 然后生成最大公因数和最小公倍数罢了 很简单只是拿来当例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fastRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fastWrite</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        fastWrite(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;<span class="keyword">return</span> m%n==<span class="number">0</span>?n:gcd(n,m%n);&#125;<span class="comment">//这个就是那个最大公因数 用了递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> gcd)</span> &#123;<span class="keyword">return</span> (n*m)/gcd;&#125;<span class="comment">//最小公倍数的公式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m=fastRead(),n=fastRead();</span><br><span class="line">    <span class="type">int</span> res = gcd(m,n);</span><br><span class="line">    fastWrite(res);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    fastWrite(lcm(m,n,res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法类 </tag>
            
            <tag> gcd </tag>
            
            <tag> 最大公因数 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/offline.html"/>
      <url>/offline.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!doctype html><html lang="zh-CN"><head>  <meta charset="utf-8">  <title>离线模式 | mymod233</title>  <meta name="viewport" content="width=device-width, initial-scale=1">  <meta name="theme-color" content="#1e1e2e">  <style>    :root { --bg:#1e1e2e; --fg:#e5e7eb; --muted:#9aa4b2; --accent1:#3b82f6; --accent2:#a855f7; }    html,body{height:100%}    body{      margin:0; background: radial-gradient(1200px 800px at 20% 10%, rgba(59,130,246,.15), transparent 60%),                 radial-gradient(1000px 700px at 80% 90%, rgba(168,85,247,.12), transparent 60%),                 var(--bg);      color:var(--fg); font:16px/1.6 system-ui,-apple-system,"Segoe UI",Roboto,Inter,"Helvetica Neue",Arial;      display:flex; align-items:center; justify-content:center; padding:24px;    }    .card{width:min(720px,90vw); background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06);      border-radius:20px; padding:28px 28px 22px; box-shadow:0 10px 30px rgba(0,0,0,.35); backdrop-filter: blur(6px);}    .logo{width:84px;height:84px;border-radius:24px;background:      linear-gradient(135deg, rgba(59,130,246,.9), rgba(168,85,247,.9));      display:flex;align-items:center;justify-content:center;margin-bottom:14px; box-shadow:0 8px 24px rgba(99,102,241,.35);}    .logo span{font-weight:800;font-size:52px;color:white;letter-spacing:.5px}    h1{margin:0 0 6px 0;font-size:26px;font-weight:800}    p{margin:6px 0;color:var(--muted)}    .actions{margin-top:18px;display:flex;gap:10px;flex-wrap:wrap}    .btn{appearance:none;border:none;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}    .primary{background:linear-gradient(135deg, #3b82f6, #a855f7); color:#fff}    .ghost{background:transparent; color:#cbd5e1; border:1px solid rgba(255,255,255,.15)}    .tips{margin-top:10px;font-size:13px;color:#b3bdc9}    code{background:rgba(255,255,255,.06);padding:2px 6px;border-radius:6px}  </style></head><body>  <main class="card" role="main" aria-label="离线提示">    <div class="logo"><span>M</span></div>    <h1>你现在处于离线状态</h1>    <p>网络连接不可用。已缓存的页面和静态资源仍可访问。恢复网络后会自动回到最新内容。</p>    <div class="actions">      <button class="btn primary" onclick="location.reload()">重试连接</button>      <button class="btn ghost" onclick="history.back()">返回上一页</button>    </div>    <p class="tips">提示：当你再次联网后，浏览器会自动更新缓存。如果仍旧显示旧内容，按 <code>Ctrl/Cmd + F5</code> 强刷。</p>  </main></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"mymod233","short_name":"mymod","start_url":"/","display":"standalone","background_color":"#1e1e2e","theme_color":"#1e1e2e","icons":[{"src":"/images/icons/icon-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/images/icons/icon-512x512.png","sizes":"512x512","type":"image/png"}]}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/sw.js"/>
      <url>/sw.js</url>
      
        <content type="html"><![CDATA[/* sw.js — mymod233 进阶版 PWA   功能：静态资源 Cache First、页面 Network First、离线 fallback、更新提醒*/const CACHE_VERSION = 'v3';              // ← 每次改动SW时+1，强制让用户拿到新版本const RUNTIME_CACHE = `pwa-mymod-${CACHE_VERSION}`;const STATIC_PATTERN = /\.(?:js|css|png|jpg|jpeg|gif|svg|woff2?)$/i;const OFFLINE_URL = '/offline.html';// 安装：预缓存离线页（不要预缓存一大堆，Hexo 更新频繁）self.addEventListener('install', event => {  event.waitUntil(    caches.open(RUNTIME_CACHE).then(cache => cache.addAll([OFFLINE_URL])).then(() => self.skipWaiting())  );});// 激活：清理旧缓存，接管页面self.addEventListener('activate', event => {  event.waitUntil(    caches.keys().then(keys =>      Promise.all(keys.filter(k => k !== RUNTIME_CACHE).map(k => caches.delete(k)))    ).then(() => self.clients.claim())  );});// 获取：静态资源 Cache First，页面 Network First + 离线兜底self.addEventListener('fetch', event => {  const req = event.request;  if (req.method !== 'GET') return;  const url = new URL(req.url);  // 静态资源：缓存优先  if (STATIC_PATTERN.test(url.pathname)) {    event.respondWith(      caches.open(RUNTIME_CACHE).then(cache =>        cache.match(req).then(hit => {          const fromNet = fetch(req).then(res => {            if (res.ok) cache.put(req, res.clone());            return res;          }).catch(() => hit);          return hit || fromNet;        })      )    );    return;  }  // 页面：网络优先，失败用缓存，再失败给离线页  if (req.mode === 'navigate' || (req.headers.get('accept') || '').includes('text/html')) {    event.respondWith(      fetch(req).then(res => {        const clone = res.clone();        caches.open(RUNTIME_CACHE).then(c => c.put(req, clone));        return res;      }).catch(async () => {        const cached = await caches.match(req);        return cached || caches.match(OFFLINE_URL);      })    );    return;  }  // 其他 GET：尽量走网络，失败尝试缓存  event.respondWith(    fetch(req).catch(() => caches.match(req))  );});// 接收页面消息：允许页面请求立即激活新SWself.addEventListener('message', event => {  if (!event.data) return;  if (event.data === 'SKIP_WAITING') {    self.skipWaiting();  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 一张全站壁纸：滚动也不换场景 */html,body{height:100%}body{  background-image:url('/images/icons/wall.jpg');  background-size:cover;  background-position:center center;  background-repeat:no-repeat;  background-attachment:fixed;}/* 封面就是“文字层”：把封面自己的底图和大遮罩关掉 */.cover, .cover .cover-img, .cover .bg{  background:transparent !important;  background-image:none !important;}.cover .mask, .cover .cover-mask{  background: rgba(0,0,0,0.15) !important; /* 想更通透就再小点或直接透明 */}/* 封面高度铺满一屏，像你给的样例一样 */.cover{height:100vh !important}/* 下面整块布局别再铺白底，全部透下去 */#page, #body-wrap, .layout, .main-inner, #content-inner, #recent-posts, .aside-content{  background:transparent !important;}/* 卡片半透明 + 轻磨砂，保证读得清 */.card, .card-widget, .recent-posts .recent-post-item, .post-block, .post-content,.timeline, .category-list, .tag-cloud, .pagination .page-number, .pagination .extend{  background: rgba(255,255,255,0.82) !important;  backdrop-filter: blur(10px) saturate(180%);  -webkit-backdrop-filter: blur(10px) saturate(180%);}/* 夜间模式下的卡片透明度 */[data-theme="dark"] .card, [data-theme="dark"] .card-widget,[data-theme="dark"] .recent-posts .recent-post-item, [data-theme="dark"] .post-block,[data-theme="dark"] .post-content, [data-theme="dark"] .timeline,[data-theme="dark"] .category-list, [data-theme="dark"] .tag-cloud,[data-theme="dark"] .pagination .page-number, [data-theme="dark"] .pagination .extend{  background: rgba(0,0,0,0.42) !important;}/* 顶栏也做成悬浮透明（需要的话） */#nav{background:transparent !important; box-shadow:none !important}#nav .menus_items .menus_item:hover{background:rgba(0,0,0,0.08)}[data-theme="dark"] #nav .menus_items .menus_item:hover{background:rgba(255,255,255,0.08)}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/force-dark-pages.js"/>
      <url>/js/force-dark-pages.js</url>
      
        <content type="html"><![CDATA[;(function () {  // 需要强制暗色的路径规则，自行补充  var forceDark = /^\/(page|about|links|music)(\/|$)/i.test(location.pathname);  if (!forceDark) return;  // 1) 立刻设为 dark  try { localStorage.setItem('theme', 'dark'); } catch (e) {}  var html = document.documentElement;  html.setAttribute('data-theme', 'dark');  html.classList.add('force-dark-page');  // 2) 隐藏可能存在的主题切换按钮（多写几种常见选择器以防主题版本差异）  var hideSwitch = function () {    var selectors = [      '#toggle-mode', '.toggle-mode', '.toggle-theme', '.darkmode-switch',      '.mode', '.site-nav .mode', '.navbar .mode'    ];    selectors.forEach(function (sel) {      document.querySelectorAll(sel).forEach(function (el) {        el.style.setProperty('display', 'none', 'important');        el.setAttribute('aria-hidden', 'true');      });    });  };  hideSwitch();  // 3) 监听 data-theme，防止被外部脚本改回 light  var obs = new MutationObserver(function (muts) {    if (html.getAttribute('data-theme') !== 'dark') {      html.setAttribute('data-theme', 'dark');    }    hideSwitch();  });  obs.observe(html, { attributes: true, attributeFilter: ['data-theme'] });  // 4) 某些主题用 prefers-color-scheme，直接硬顶一层样式变量  var css = document.createElement('style');  css.textContent =    'html.force-dark-page{color-scheme: dark !important;}';  document.head.appendChild(css);})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!DOCTYPE html><html><head>  <meta charset="utf-8">  <title>Music</title>  <meta name="viewport" content="width=device-width, initial-scale=1" />  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">  <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>  <style>    body { margin: 0; padding: 2rem; font-family: system-ui, sans-serif; }    .wrap { max-width: 960px; margin: 0 auto; }  </style></head><body>  <div class="wrap">    <h1>My Playlist</h1>    <!-- 页内可见列表播放器 -->    <meting-js      server="netease"      type="playlist"      id="14437180364"      fixed="false"      autoplay="false"      order="random"      loop="all"      list-folded="false"      list-max-height="420"      preload="auto">    </meting-js>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>message</title>
      <link href="/message/index.html"/>
      <url>/message/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class='p center logo large'>个人介绍</p><p class='p center small'>A Wonderful Theme for Hexo</p><h2 id="大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！-⁠-⁠≧⁠Д⁠≦⁠"><a href="#大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！-⁠-⁠≧⁠Д⁠≦⁠" class="headerlink" title="大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！(⁠ ⁠≧⁠Д⁠≦⁠)"></a>大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！(⁠ ⁠≧⁠Д⁠≦⁠)</h2><p>本人也就只是懂<strong>一点点</strong>电脑技术罢了 并不是那种比较会的哦 什么<strong>GitHub</strong>那些也都是最近才弄的啦！(⁠╯⁠︵⁠╰⁠,⁠)</p><p>本人的<strong>兴趣爱好</strong>都比较多啦 最喜欢的就是<strong>听音乐</strong> (<psw>猜猜我喜欢听什么www</psw>)其次才是弄<strong>电脑</strong> 体育的话喜欢<strong>棒球</strong>和<strong>职业摔角</strong>(<del>这么小众的爱好应该没有人喜欢</del>) 但是最喜欢的运动还是<strong>职业摔角</strong>啦 当然最了解的也是职业摔角www（我可是5岁看摔角看到现在的呢！(⁠ ⁠；⁠∀⁠；⁠)）</p><p>我大学的专业是<strong>计算机科学与技术</strong> 因为我想<strong>逃避算法</strong>www(<emp>事实证明我是错的呜呜呜</emp>) 我初中就是打<strong>算法竞赛</strong>的 给我弄的长脑子了</p><p>我听音乐的话主要是我小时候<strong>学架子鼓</strong> 因此对音乐都是<strong>非常敏感</strong>的 小<strong>时候还被老师夸过说我很有天赋欸嘿嘿</strong>(<del>真的很自豪的说</del>) 所以说我<strong>听音乐也是很广泛</strong>的 中文的话比较喜欢<strong>中文说唱 主要是旋律说唱emo说唱二次元说唱之类的</strong> 因为听这些其实对于我来说<strong>像是找共鸣 因为他们的歌词很直白也很贴近生活嘛 正是因为门槛低所以我就很喜欢</strong> 日语的歌的话倒是流行的都听 因为日本那边的音乐都是挺好的嘛 <strong>至于欧美的话我就偏向于neo-soul啊R&amp;B之类</strong>(<del>又小众了起来嘤嘤</del>)的 我很喜欢爵士还有neo-soul 类似的风格 因为很独特很舒服 这一类的歌就不在意歌词了 如果是听中文说唱对于我来说那就是旋律+歌词和那种意识是我最喜欢的啦</p><p>说到这里推荐几位歌手啦!(<del>当然是中文说唱的www</del>)<br><div class="tag link"><a class="link-card" title="MISTERK" href="https://music.163.com/#/artist?id=12256230"><div class="left"><img src="/img/link.png"/></div><div class="right"><p class="text">MISTERK</p><p class="url">https://music.163.com/#/artist?id=12256230</p></div></a></div></p><h2 id="这位是真的非常非常喜欢啦-二次原说唱是最屌的"><a href="#这位是真的非常非常喜欢啦-二次原说唱是最屌的" class="headerlink" title="这位是真的非常非常喜欢啦 二次原说唱是最屌的!!!()"></a>这位是真的非常非常喜欢啦 二次原说唱是最屌的!!!(<del>不接受任何反驳</del>)</h2><div class="tag link"><a class="link-card" title="河南说唱之神" href="https://music.163.com/#/artist?id=15194340"><div class="left"><img src="/img/link.png"/></div><div class="right"><p class="text">河南说唱之神</p><p class="url">https://music.163.com/#/artist?id=15194340</p></div></a></div><h2 id="忧郁之神啦-母庸置疑的"><a href="#忧郁之神啦-母庸置疑的" class="headerlink" title="忧郁之神啦!!!母庸置疑的"></a>忧郁之神啦!!!母庸置疑的</h2><div class="tag link"><a class="link-card" title="BOBBYNOPACE" href="https://music.163.com/#/artist?id=48277407"><div class="left"><img src="/img/link.png"/></div><div class="right"><p class="text">BOBBYNOPACE</p><p class="url">https://music.163.com/#/artist?id=48277407</p></div></a></div><h2 id=""><a href="#" class="headerlink" title=""></a><del>永远的佐助</del></h2><h2 id="总而言之-最喜欢大家啦"><a href="#总而言之-最喜欢大家啦" class="headerlink" title="总而言之 最喜欢大家啦!!!"></a>总而言之 最喜欢大家啦!!!</h2>]]></content>
      
    </entry>
    
    
  
</search>
