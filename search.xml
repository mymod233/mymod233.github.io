<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c语言期中考试错题汇总</title>
      <link href="/posts/828471d6.html"/>
      <url>/posts/828471d6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="期中考错题汇总"><a href="#期中考错题汇总" class="headerlink" title="期中考错题汇总"></a>期中考错题汇总</h1><hr><h1 id="❌-错题记录：C-语言八进制陷阱"><a href="#❌-错题记录：C-语言八进制陷阱" class="headerlink" title="❌ 错题记录：C 语言八进制陷阱"></a>❌ 错题记录：C 语言八进制陷阱</h1><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a><strong>题目：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4、【单选题】下列程序段输出结果为：（ ）</span><br><span class="line"></span><br><span class="line">int x = 1, y = 012;</span><br><span class="line">printf(&quot;%d&quot;, y * x++);</span><br></pre></td></tr></table></figure><h3 id="你的答案："><a href="#你的答案：" class="headerlink" title="你的答案："></a><strong>你的答案：</strong></h3><p><strong>B. 12（错误）</strong></p><h3 id="正确答案："><a href="#正确答案：" class="headerlink" title="正确答案："></a><strong>正确答案：</strong></h3><p><strong>C. 10</strong></p><hr><h1 id="✅-解析："><a href="#✅-解析：" class="headerlink" title="✅ 解析："></a>✅ 解析：</h1><h3 id="关键点：012-是八进制数"><a href="#关键点：012-是八进制数" class="headerlink" title="关键点：012 是八进制数"></a><strong>关键点：<code>012</code> 是八进制数</strong></h3><ul><li>C 语言中，<strong>以 0 开头的整数是八进制（base 8）</strong></li><li><code>012</code> = 八进制 12 = 十进制 <code>1*8 + 2 = 10</code></li></ul><p>所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = 10</span><br></pre></td></tr></table></figure><hr><h3 id="表达式：y-x"><a href="#表达式：y-x" class="headerlink" title="表达式：y \* x++"></a><strong>表达式：<code>y \* x++</code></strong></h3><ul><li><code>x++</code> 是后置自增：先使用，再自增</li><li>表达式中使用的是 x = 1</li><li>用完之后 x → 2（但与输出无关）</li></ul><p>因此：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y * x++ = 10 * 1 = 10</span><br></pre></td></tr></table></figure><hr><h1 id="🎯-最终输出："><a href="#🎯-最终输出：" class="headerlink" title="🎯 最终输出："></a>🎯 最终输出：</h1><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></h2><h1 id="🔹-题目-10：赋值表达式右结合陷阱"><a href="#🔹-题目-10：赋值表达式右结合陷阱" class="headerlink" title="🔹 题目 10：赋值表达式右结合陷阱"></a>🔹 题目 10：赋值表达式右结合陷阱</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h3><p>执行以下语句后，<code>a</code> 的值为多少？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>;</span><br><span class="line">a += a = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>A. 15</li><li>B. 10</li><li>C. 20</li><li>D. 5</li></ul><h3 id="我的答案"><a href="#我的答案" class="headerlink" title="我的答案"></a><strong>我的答案</strong></h3><p>D. 5（错误）</p><h3 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a><strong>正确答案</strong></h3><p>B. 10</p><hr><h1 id="✅-解析"><a href="#✅-解析" class="headerlink" title="✅ 解析"></a>✅ 解析</h1><p>表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += a = 5;</span><br></pre></td></tr></table></figure><p>关键点：</p><h3 id="①-赋值运算符-的结果值是右侧的值"><a href="#①-赋值运算符-的结果值是右侧的值" class="headerlink" title="① 赋值运算符 = 的结果值是右侧的值"></a>① 赋值运算符 <code>=</code> 的结果值是右侧的值</h3><p>所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a = 5) 的结果值是 5</span><br></pre></td></tr></table></figure><h3 id="②-赋值表达式从右向左结合"><a href="#②-赋值表达式从右向左结合" class="headerlink" title="② 赋值表达式从右向左结合"></a>② 赋值表达式从右向左结合</h3><p>所以执行顺序是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 5;          // 第一次赋值</span><br><span class="line">a += (a = 5);   // 先执行右侧 a = 5，再将值 5 加到前面的 a 上</span><br></pre></td></tr></table></figure><h3 id="③-执行过程逐步展开："><a href="#③-执行过程逐步展开：" class="headerlink" title="③ 执行过程逐步展开："></a>③ 执行过程逐步展开：</h3><ol><li><p>执行 <code>a = 5</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br></pre></td></tr></table></figure></li><li><p>计算右边 <code>(a = 5)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">表达式值为 5</span><br></pre></td></tr></table></figure></li><li><p>执行 <code>a += 5</code><br> 等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a + 5 = 5 + 5 = 10</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="🎯-最终结果"><a href="#🎯-最终结果" class="headerlink" title="🎯 最终结果"></a>🎯 最终结果</h1><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br></pre></td></tr></table></figure></h2><h1 id="🔹-题目-16：if-语句作用域被逗号误读"><a href="#🔹-题目-16：if-语句作用域被逗号误读" class="headerlink" title="🔹 题目 16：if 语句作用域被逗号误读"></a>🔹 题目 16：if 语句作用域被逗号误读</h1><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a><strong>题目</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, x, y;</span><br><span class="line">i = x = y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ++i;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">        x += i,</span><br><span class="line">        i++;</span><br><span class="line">    y += i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, i, x, y);</span><br></pre></td></tr></table></figure><h3 id="我的答案-1"><a href="#我的答案-1" class="headerlink" title="我的答案"></a><strong>我的答案</strong></h3><p>9 8 15（错误）</p><h3 id="正确答案-1"><a href="#正确答案-1" class="headerlink" title="正确答案"></a><strong>正确答案</strong></h3><p>9 1 20</p><h3 id="错误原因（关键点）"><a href="#错误原因（关键点）" class="headerlink" title="错误原因（关键点）"></a><strong>错误原因（关键点）</strong></h3><ul><li><code>x += i,</code> 这一行末尾没有分号</li><li><strong>下面的 <code>i++</code> 实际上是和上面一起属于 if 语句块</strong></li></ul><p>也就是说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">    x += i;</span><br><span class="line">    i++;     <span class="comment">// 这个 i++ 也在 if 里面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你原本把它误解成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">    x += i;</span><br><span class="line">i++;         <span class="comment">// 实际上不是这样的</span></span><br></pre></td></tr></table></figure><h2 id="因此-if-每次只在奇数-i-才会执行两句，而你之前把第二句当成-if-外的逻辑，导致结果计算错误。"><a href="#因此-if-每次只在奇数-i-才会执行两句，而你之前把第二句当成-if-外的逻辑，导致结果计算错误。" class="headerlink" title="因此 if 每次只在奇数 i 才会执行两句，而你之前把第二句当成 if 外的逻辑，导致结果计算错误。"></a>因此 if 每次只在奇数 i 才会执行两句，而你之前把第二句当成 if 外的逻辑，导致结果计算错误。</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应付考试 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 基础概念 </tag>
            
            <tag> 错题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言出错概念</title>
      <link href="/posts/3bf41286.html"/>
      <url>/posts/3bf41286.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C语言期末考客观题出错汇总"><a href="#C语言期末考客观题出错汇总" class="headerlink" title="C语言期末考客观题出错汇总"></a>C语言期末考客观题出错汇总</h1><ol><li>C语言源程序的基本单位是<code>函数</code></li><li>C语言是一种<code>高级</code>程序语言</li><li>在一个源程序中，main函数的位置<code>可以任意</code></li><li>能将高级语言程序转换成目标语言程序的是<code>编译程序</code></li><li>C语言中的每条可执行语句最终都将被转成二进制的机器指令</li><li>C语言程序从<code>main函数</code>开始执行</li><li>C语言中的<strong>简单数据类型</strong>包括<code>整型,实型,字符型</code></li><li>printf(“%d%d%d”,sizeof(int),sizeof(char), sizeof(“56”));正确结果是<code>413</code></li><li>逻辑运算符两侧运算对象的数据类型可以是<code>任何类型的数据</code></li><li>为了避免嵌套的if-else语句的二义性，C语言规定else总是<code>与在其之前尚未配对的最近的if</code>组成配对关系。</li><li>C语言中，逻辑运算符的优先级从高到低依次是<code>! &amp;&amp; ||</code></li><li>使用scanf的时候<code>它的格式字符串中不能包含函变量名</code></li><li>下列关于单目运算符++、—的叙述中 <code>他们的运算对象可以是char,int,float</code></li><li>程序的三种基本结构是<code>顺序结构,循环结构,选择结构</code></li><li>符号常量就是用<code>#define定义的</code></li><li>break语句的功能是<code>跳出循环</code>，执行后面的语句</li><li>else子句总是<code>与其之前最近的if</code>配对</li><li>while(x)中等价于<code>while(x!=0)</code></li><li>在大循环中 一定要有能使while后面表达式的值变成零(“假”)的操作</li><li>for循环的执行流程是<code>先执行初始化表达式，然后不断循环执行条件表达式、循环体和迭代表达式</code></li><li>do…while语句的特点是<code>循环体至少执行一次</code></li><li>循环结构的循环体<code>可以不用使用花括号{}括起来</code></li><li>while循环的循环体至少会执行一次(<code>错的</code>)</li><li>循环结构的三要素包括<code>循环变量、循环体和循环终止条件</code></li><li>在C语言中，<strong>当型循环语句</strong>是while语句</li><li>只要<strong>适当地修改代码</strong>，就可以将<code>do-while与while</code><strong>相互转换</strong></li><li>在C语言中，for循环可以嵌套使用，例如一个for循环内部还可以包含另一个for循环 这种称为<code>嵌套循环</code></li><li>switch语句中必须有break语句，否则无法退出switch语句。(<code>错</code>)</li><li>若i为整型变量，则以下循环i=0;while(i=0) i++;一次也不执行(<code>错</code>) 这个写法也没有问题 while(i=0)等价于while(里面是i的值)因为i=0 那么语句可以等价为while(0)</li><li><strong>break语句</strong>只能用在<code>循环体内和switch语句</code>体内</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应付考试 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 基础概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深搜的相关的知识&amp;树的一些</title>
      <link href="/posts/3ca83f46.html"/>
      <url>/posts/3ca83f46.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="深搜的相关的知识"><a href="#深搜的相关的知识" class="headerlink" title="深搜的相关的知识"></a>深搜的相关的知识</h1><p>想象有一棵树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br></pre></td></tr></table></figure><p>这5个点我们就给它们编号：<code>1, 2, 3, 4, 5</code>。<br> 编号相当于“身份证号”，每个节点都有一个独一无二的号码。</p><hr><h2 id="二、我们要干的事"><a href="#二、我们要干的事" class="headerlink" title="二、我们要干的事"></a>二、我们要干的事</h2><p>我们要告诉电脑：</p><ul><li>每个节点有哪些孩子；</li><li>然后从根（1号）出发，去深搜所有节点。</li></ul><hr><h2 id="三、先造存储结构（这部分最关键）"><a href="#三、先造存储结构（这部分最关键）" class="headerlink" title="三、先造存储结构（这部分最关键）"></a>三、先造存储结构（这部分最关键）</h2><p>在C++里，我们用一个<strong>邻接表（adjacency list）</strong>表示“谁连着谁”。</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int N = 100;         // 最多100个节点</span><br><span class="line">vector&lt;int&gt; tree[N];       // 每个节点的孩子列表</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>tree[1]</code> 是一个数组，里面放着“1的孩子”；</li><li><code>tree[2]</code> 是“2的孩子”；</li><li>以此类推。</li></ul><hr><h2 id="四、把上面的树存进去"><a href="#四、把上面的树存进去" class="headerlink" title="四、把上面的树存进去"></a>四、把上面的树存进去</h2><p>根据图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2, 3</span><br><span class="line">3 -&gt; 4, 5</span><br></pre></td></tr></table></figure><p>所以我们写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tree[1].push_back(2);</span><br><span class="line">tree[1].push_back(3);</span><br><span class="line">tree[3].push_back(4);</span><br><span class="line">tree[3].push_back(5);</span><br></pre></td></tr></table></figure><p>现在内存里相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = [2, 3]</span><br><span class="line">tree[2] = []</span><br><span class="line">tree[3] = [4, 5]</span><br><span class="line">tree[4] = []</span><br><span class="line">tree[5] = []</span><br></pre></td></tr></table></figure><hr><h2 id="五、写-DFS-函数（核心！）"><a href="#五、写-DFS-函数（核心！）" class="headerlink" title="五、写 DFS 函数（核心！）"></a>五、写 DFS 函数（核心！）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int u) &#123;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; &quot; &quot;;             // 访问当前节点</span><br><span class="line">    for (int v : tree[u]) &#123;       // 遍历当前节点的孩子</span><br><span class="line">        dfs(v);                   // 深度优先地访问</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释成日常语言：</p><blockquote><p>“我现在在节点u，我先打印自己。<br> 然后看看我的每个孩子v，挨个去访问。<br> 每次都走到底，再回来。”</p></blockquote><hr><h2 id="六、主函数完整代码"><a href="#六、主函数完整代码" class="headerlink" title="六、主函数完整代码"></a>六、主函数完整代码</h2><p>把上面都拼起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[N]; <span class="comment">// 存树结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>;             <span class="comment">// 打印当前节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : tree[u]) &#123;       <span class="comment">// 遍历孩子</span></span><br><span class="line">        <span class="built_in">dfs</span>(v);                   <span class="comment">// 深入孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建树</span></span><br><span class="line">    tree[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    tree[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    tree[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    tree[<span class="number">3</span>].<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从1号节点开始深搜</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p>访问顺序：<br> 1 → 2（到头）→ 回来 → 3 → 4 → 回来 → 5</p><p>完美的深搜逻辑！</p><hr><h2 id="七、要理解的关键点"><a href="#七、要理解的关键点" class="headerlink" title="七、要理解的关键点"></a>七、要理解的关键点</h2><div class="table-container"><table><thead><tr><th>概念</th><th>傻瓜理解</th></tr></thead><tbody><tr><td><code>vector&lt;int&gt; tree[N];</code></td><td>N个小盒子，每个盒子装当前节点的孩子编号</td></tr><tr><td><code>push_back(x)</code></td><td>把编号x放进这个节点的孩子列表</td></tr><tr><td><code>dfs(u)</code></td><td>看自己 → 递归去找所有孩子</td></tr><tr><td>递归</td><td>程序会“自己调用自己”，走到底再回来</td></tr><tr><td>没有指针</td><td>因为我们用编号连关系，电脑自己能找得到孩子</td></tr></tbody></table></div><h1 id="关于深搜的核心写法的疑惑"><a href="#关于深搜的核心写法的疑惑" class="headerlink" title="关于深搜的核心写法的疑惑:"></a>关于深搜的核心写法的疑惑:</h1><h3 id="一、先看原句"><a href="#一、先看原句" class="headerlink" title="一、先看原句"></a>一、先看原句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int v : tree[u]) &#123;</span><br><span class="line">    dfs(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是：</p><blockquote><p>遍历当前节点 <code>u</code> 的所有孩子节点（存在 <code>tree[u]</code> 这个列表里），<br> 对每个孩子 <code>v</code> 都递归调用 <code>dfs(v)</code>，去继续往下搜。</p></blockquote><hr><h3 id="二、先解释-tree-u"><a href="#二、先解释-tree-u" class="headerlink" title="二、先解释 tree[u]"></a>二、先解释 <code>tree[u]</code></h3><p>在数组版树结构里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; tree[N];</span><br></pre></td></tr></table></figure><p><code>tree</code> 是一个“数组”，它里面的每个元素都是一个“孩子列表”。</p><p>举个例子（刚才那棵树）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = [2, 3]</span><br><span class="line">tree[2] = []</span><br><span class="line">tree[3] = [4, 5]</span><br></pre></td></tr></table></figure><p>这意思就是：</p><ul><li>1 号节点有孩子 2、3</li><li>2 没孩子</li><li>3 的孩子是 4、5</li></ul><p>所以 <code>tree[u]</code> 就是“u号节点的所有孩子”。</p><hr><h3 id="三、再解释-for-int-v-tree-u"><a href="#三、再解释-for-int-v-tree-u" class="headerlink" title="三、再解释 for (int v : tree[u])"></a>三、再解释 <code>for (int v : tree[u])</code></h3><p>这是 <strong>C++ 的范围 for 循环（range-based for loop）</strong>，<br> 读法是：</p><blockquote><p>“对于 <code>tree[u]</code> 里的每一个元素，依次取出放进变量 <code>v</code> 里”。</p></blockquote><p>等价的老式写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; tree[u].size(); ++i) &#123;</span><br><span class="line">    int v = tree[u][i];</span><br><span class="line">    dfs(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int v : tree[u])</span><br></pre></td></tr></table></figure><p>其实就是：</p><blockquote><p>“拿出当前节点u的每一个孩子v”。</p></blockquote><hr><h3 id="四、然后执行-dfs-v"><a href="#四、然后执行-dfs-v" class="headerlink" title="四、然后执行 dfs(v)"></a>四、然后执行 <code>dfs(v)</code></h3><p><code>dfs(v)</code> 就是让程序“去访问这个孩子”。<br> 因为DFS是<strong>递归</strong>，它自己又会：</p><ol><li>打印v；</li><li>再去访问v的孩子；</li><li>直到走到底；</li><li>再回来继续访问下一个孩子。</li></ol><p>整个过程像人钻洞：</p><ul><li>你现在在洞口u；</li><li>看看有几个分岔口（孩子）；</li><li>每个口（v）都钻到底；</li><li>再返回来钻下一个。</li></ul><hr><h3 id="五、加点“傻瓜式比喻”"><a href="#五、加点“傻瓜式比喻”" class="headerlink" title="五、加点“傻瓜式比喻”"></a>五、加点“傻瓜式比喻”</h3><p>假设 <code>tree[1] = [2, 3]</code>，<code>tree[3] = [4, 5]</code>。</p><p>程序运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(1)</span><br></pre></td></tr></table></figure><p>流程是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进入1：</span><br><span class="line">  打印1</span><br><span class="line">  for循环拿到v=2 → dfs(2)</span><br><span class="line">    打印2（没孩子）</span><br><span class="line">  for循环拿到v=3 → dfs(3)</span><br><span class="line">    打印3</span><br><span class="line">    for循环拿到v=4 → dfs(4)</span><br><span class="line">      打印4</span><br><span class="line">    for循环拿到v=5 → dfs(5)</span><br><span class="line">      打印5</span><br><span class="line">全部结束</span><br></pre></td></tr></table></figure><p>最后输出：<code>1 2 3 4 5</code>。</p><hr><h3 id="六、总结成一句话："><a href="#六、总结成一句话：" class="headerlink" title="六、总结成一句话："></a>六、总结成一句话：</h3><div class="table-container"><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>for (int v : tree[u])</code></td><td>从节点u的孩子列表中，一个一个取出孩子v</td></tr><tr><td><code>dfs(v)</code></td><td>对每个孩子再递归进行DFS</td></tr><tr><td>整体逻辑</td><td>“访问u → 对每个孩子都做DFS”</td></tr></tbody></table></div><hr><p>所以它其实干的事很像一句人话：</p><blockquote><p>“我现在在u节点，我要去看它所有的孩子，每个孩子都得进去转一圈。”</p></blockquote><hr><p>如果你愿意，我可以帮你把这两行“展开成一整轮递归过程图”，<br> 就能直观地看到程序是怎么一层层下去、又一层层回来的。</p><h1 id="关于深搜老式写法的疑惑"><a href="#关于深搜老式写法的疑惑" class="headerlink" title="关于深搜老式写法的疑惑:"></a>关于深搜老式写法的疑惑:</h1><h2 id="一、背景先记牢"><a href="#一、背景先记牢" class="headerlink" title="一、背景先记牢"></a>一、背景先记牢</h2><p>我们在干的事是：</p><blockquote><p>对当前节点 <code>u</code>，找到它的所有孩子，然后对每个孩子都 <code>dfs(v)</code>。</p></blockquote><p>你可以理解成：</p><blockquote><p>“我现在在 1 号点，看看它有几个孩子（比如 2 和 3），我一个个去拜访。”</p></blockquote><hr><h2 id="二、先看大框架"><a href="#二、先看大框架" class="headerlink" title="二、先看大框架"></a>二、先看大框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; tree[u].size(); ++i) &#123;</span><br><span class="line">    int v = tree[u][i];</span><br><span class="line">    dfs(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种普通的 <strong>for循环</strong>。<br> 我们来翻译成中文：</p><blockquote><p>“从 i = 0 开始，一直数到 <code>tree[u].size() - 1</code>，<br> 每次都取出第 i 个孩子 <code>v</code>，<br> 然后对这个孩子执行 <code>dfs(v)</code>。”</p></blockquote><hr><h2 id="三、逐个词拆开解释"><a href="#三、逐个词拆开解释" class="headerlink" title="三、逐个词拆开解释"></a>三、逐个词拆开解释</h2><h3 id="tree-u"><a href="#tree-u" class="headerlink" title="tree[u]"></a><code>tree[u]</code></h3><p>还是那句话：<br> <code>tree[u]</code> 是“u号节点的所有孩子”。<br> 比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = [2, 3]</span><br></pre></td></tr></table></figure><p>说明 1 的孩子是 2 和 3。</p><hr><h3 id="tree-u-size"><a href="#tree-u-size" class="headerlink" title="tree[u].size()"></a><code>tree[u].size()</code></h3><p>表示孩子的数量。<br> 比如 <code>tree[1].size()</code> = 2（因为1有两个孩子）。</p><p>所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; tree[u].size(); ++i)</span><br></pre></td></tr></table></figure><p>就等于：</p><blockquote><p>“从第 0 个孩子开始，一直到最后一个孩子。”</p></blockquote><hr><h3 id="tree-u-i"><a href="#tree-u-i" class="headerlink" title="tree[u][i]"></a><code>tree[u][i]</code></h3><p>这表示：</p><blockquote><p>取出 <code>u</code> 的第 i 个孩子。</p></blockquote><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = [2, 3]</span><br></pre></td></tr></table></figure><p>那：</p><ul><li><code>tree[1][0] = 2</code></li><li><code>tree[1][1] = 3</code></li></ul><p>这两个值分别是“1号节点的第0个孩子”“1号节点的第1个孩子”。</p><hr><h3 id="int-v-tree-u-i"><a href="#int-v-tree-u-i" class="headerlink" title="int v = tree[u][i];"></a><code>int v = tree[u][i];</code></h3><p>意思是：</p><blockquote><p>把当前孩子的编号取出来，放进变量 <code>v</code>。</p></blockquote><p>比如第一次循环：</p><ul><li>i=0 → v=2<br> 第二次循环：</li><li>i=1 → v=3</li></ul><hr><h3 id="dfs-v"><a href="#dfs-v" class="headerlink" title="dfs(v);"></a><code>dfs(v);</code></h3><p>这句就是：</p><blockquote><p>“对孩子节点 v 再进行一次深度优先搜索。”</p></blockquote><hr><h2 id="四、把整个循环翻译成人话："><a href="#四、把整个循环翻译成人话：" class="headerlink" title="四、把整个循环翻译成人话："></a>四、把整个循环翻译成人话：</h2><p>以 <code>u = 1</code> 为例（假设 tree[1] = [2, 3]）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 2; ++i) &#123;</span><br><span class="line">    int v = tree[1][i];</span><br><span class="line">    dfs(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行过程：</p><div class="table-container"><table><thead><tr><th>i</th><th>tree[1][i]</th><th>v的值</th><th>做的事</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>v=2</td><td>调用 <code>dfs(2)</code></td></tr><tr><td>1</td><td>3</td><td>v=3</td><td>调用 <code>dfs(3)</code></td></tr></tbody></table></div><p>所以它干的事其实就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(2);</span><br><span class="line">dfs(3);</span><br></pre></td></tr></table></figure><p>只是写成循环自动处理，不用你手动列。</p><hr><h2 id="五、再画个逻辑图（想象程序脑子里的流程）"><a href="#五、再画个逻辑图（想象程序脑子里的流程）" class="headerlink" title="五、再画个逻辑图（想象程序脑子里的流程）"></a>五、再画个逻辑图（想象程序脑子里的流程）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入 dfs(1)</span><br><span class="line">|</span><br><span class="line">|—— i=0 → v=2 → dfs(2)</span><br><span class="line">|—— i=1 → v=3 → dfs(3)</span><br></pre></td></tr></table></figure><hr><h2 id="六、和新写法对比一下（你会立刻懂）"><a href="#六、和新写法对比一下（你会立刻懂）" class="headerlink" title="六、和新写法对比一下（你会立刻懂）"></a>六、和新写法对比一下（你会立刻懂）</h2><div class="table-container"><table><thead><tr><th>新写法（简化版）</th><th>老写法（展开版）</th></tr></thead><tbody><tr><td><code>for (int v : tree[u]) dfs(v);</code></td><td><code>for (int i = 0; i &lt; tree[u].size(); ++i) { int v = tree[u][i]; dfs(v); }</code></td></tr></tbody></table></div><p>意思完全一样。<br> 新写法更短、更清爽，<br> 老写法是手动数下标的版本，适合旧标准（C++98）。</p><hr><h2 id="七、终极一句话总结"><a href="#七、终极一句话总结" class="headerlink" title="七、终极一句话总结"></a>七、终极一句话总结</h2><blockquote><p>这三行代码的意思是：<br> “从第0个孩子开始，一个个取出来，<br> 让每个孩子都跑一遍DFS。”</p></blockquote><h1 id="可是要是有一个点上没有孩子-那为什么不会返回0呢"><a href="#可是要是有一个点上没有孩子-那为什么不会返回0呢" class="headerlink" title="可是要是有一个点上没有孩子 那为什么不会返回0呢"></a>可是要是有一个点上没有孩子 那为什么不会返回0呢</h1><h2 id="一、先看你说的情况"><a href="#一、先看你说的情况" class="headerlink" title="一、先看你说的情况"></a>一、先看你说的情况</h2><p>假设我们有一棵树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure><p>那在代码里是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = [2, 3];</span><br><span class="line">tree[2] = [];</span><br><span class="line">tree[3] = [];</span><br></pre></td></tr></table></figure><p>也就是说：</p><ul><li>1号节点有两个孩子；</li><li>2号和3号是“叶子节点”，没有孩子；</li><li>对应的 <code>tree[2]</code> 和 <code>tree[3]</code> 都是空的 <code>vector&lt;int&gt;</code>。</li></ul><hr><h2 id="二、DFS会怎么跑？"><a href="#二、DFS会怎么跑？" class="headerlink" title="二、DFS会怎么跑？"></a>二、DFS会怎么跑？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int u) &#123;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; &quot; &quot;;              // 先打印自己</span><br><span class="line">    for (int v : tree[u]) &#123;        // 遍历孩子</span><br><span class="line">        dfs(v);                    // 深入孩子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们从 <code>dfs(2)</code> 开始执行。</p><hr><h3 id="第一步：进入函数"><a href="#第一步：进入函数" class="headerlink" title="第一步：进入函数"></a>第一步：进入函数</h3><p><code>u = 2</code><br> 打印出 <code>2</code></p><hr><h3 id="第二步：执行-for-循环"><a href="#第二步：执行-for-循环" class="headerlink" title="第二步：执行 for 循环"></a>第二步：执行 for 循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int v : tree[2]) &#123;</span><br><span class="line">    dfs(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了：<code>tree[2]</code> 是空的 <code>[]</code>，对吧？</p><p>那<strong>for循环里根本就没有元素可以遍历</strong>。<br> 程序就直接<strong>跳过循环体</strong>。</p><p>这时候程序不会“返回0”，因为循环本身没结果可返回。<br> C++ 的 <code>for</code> 不是返回值，而是一个<strong>控制语句</strong>，只控制“要不要执行循环体”。</p><hr><h2 id="三、重点理解："><a href="#三、重点理解：" class="headerlink" title="三、重点理解："></a>三、重点理解：</h2><p>C++ 的 <code>for</code> 不是函数，不会“返回”任何值。<br> 所以你写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int v : tree[u]) &#123;</span><br><span class="line">    dfs(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思是：</p><blockquote><p>“对每个孩子v，执行dfs(v)；<br> 如果没孩子，那就什么都不做。”</p></blockquote><p>它不会返回 0，也不会出错。<br> 程序执行完循环后，就继续往下走（也就是递归结束）。</p><hr><h2 id="四、那DFS怎么“知道”到头了？"><a href="#四、那DFS怎么“知道”到头了？" class="headerlink" title="四、那DFS怎么“知道”到头了？"></a>四、那DFS怎么“知道”到头了？</h2><p>它其实通过两层逻辑：</p><ol><li>如果 <code>tree[u]</code> 是空的，就不会进入for循环。</li><li>递归到这个节点时，发现没孩子可递归，于是<strong>自然返回上层</strong>。</li></ol><p>举个流程（以 <code>dfs(1)</code> 为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dfs(1)</span><br><span class="line"> ├── 打印 1</span><br><span class="line"> ├── 进入 for 循环 → 拿到 v=2 → dfs(2)</span><br><span class="line"> │      ├── 打印 2</span><br><span class="line"> │      ├── tree[2] 空 → 不进循环 → 返回</span><br><span class="line"> │</span><br><span class="line"> ├── 再拿 v=3 → dfs(3)</span><br><span class="line"> │      ├── 打印 3</span><br><span class="line"> │      ├── tree[3] 空 → 不进循环 → 返回</span><br><span class="line">返回上层，结束</span><br></pre></td></tr></table></figure><hr><h2 id="五、你要牢牢记住一句话："><a href="#五、你要牢牢记住一句话：" class="headerlink" title="五、你要牢牢记住一句话："></a>五、你要牢牢记住一句话：</h2><blockquote><p><strong>没有孩子 ≠ 返回0。</strong><br> 只是没有孩子可以递归了，所以“自然结束函数”。</p></blockquote><p>C++ 的函数如果写成 <code>void dfs(...)</code>，本身就没有返回值。<br> 所以DFS这种函数从头到尾都不“return 某个数”，<br> 它只是“执行完任务就返回上一级”。</p><hr><h2 id="六、打个比喻："><a href="#六、打个比喻：" class="headerlink" title="六、打个比喻："></a>六、打个比喻：</h2><p>DFS像是你带孩子探险。</p><ul><li>每次进一个洞（节点u），<br> 你会说“我来了（打印u）”。</li><li>然后你看看有没有岔路（<code>tree[u]</code>）。<ul><li>有，就挨个进去；</li><li>没有，就转身原路返回。</li></ul></li></ul><p>“返回”这个动作是自动发生的，不是“返回0”。</p><hr><h2 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h2><div class="table-container"><table><thead><tr><th>情况</th><th>程序行为</th><th>原因</th></tr></thead><tbody><tr><td>节点有孩子</td><td>依次对每个孩子递归DFS</td><td>for循环遍历非空vector</td></tr><tr><td>节点没孩子</td><td>for循环直接跳过，函数结束</td><td>空vector导致循环体不执行</td></tr><tr><td>是否返回0</td><td>否</td><td>dfs是<code>void</code>函数，无返回值</td></tr></tbody></table></div><h1 id="例-P1030-NOIP-2001-普及组-求先序排列"><a href="#例-P1030-NOIP-2001-普及组-求先序排列" class="headerlink" title="[例]P1030 [NOIP 2001 普及组] 求先序排列"></a>[例]P1030 [NOIP 2001 普及组] 求先序排列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共一行一个字符串，表示一棵二叉树的先序。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例 #1"></a>输入输出样例 #1</h2><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入 #1"></a>输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BADC</span><br><span class="line">BDCA</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出 #1"></a>输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABCD</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h2><p><strong>【题目来源】</strong></p><p>NOIP 2001 普及组第三题</p><h1 id="🚀-1-你到底在做什么？"><a href="#🚀-1-你到底在做什么？" class="headerlink" title="🚀 1. 你到底在做什么？"></a>🚀 <strong>1. 你到底在做什么？</strong></h1><p>题目给你：</p><ul><li><strong>中序遍历（in-order）</strong>：左 根 右</li><li><strong>后序遍历（post-order）</strong>：左 右 根</li></ul><p>你要求出：</p><ul><li><strong>先序遍历（pre-order）</strong>：根 左 右</li></ul><hr><h1 id="🚀-2-为什么能通过「中序-后序」推回一棵唯一的二叉树？"><a href="#🚀-2-为什么能通过「中序-后序」推回一棵唯一的二叉树？" class="headerlink" title="🚀 2. 为什么能通过「中序 + 后序」推回一棵唯一的二叉树？"></a>🚀 <strong>2. 为什么能通过「中序 + 后序」推回一棵唯一的二叉树？</strong></h1><p>关键就在：</p><ul><li>后序的<strong>最后一个字符一定是根节点</strong></li><li>中序中，根节点的位置<strong>把树分成左子树 和 右子树</strong></li></ul><p>就这么简单。</p><h3 id="比如："><a href="#比如：" class="headerlink" title="比如："></a>比如：</h3><p>中序：<code>B A D C</code><br> 后序：<code>B D C A</code></p><p>后序最后是 <code>A</code>，所以 A 是根。</p><p>然后看看 A 在中序中出现在哪：<br> <code>B A D C</code><br> ↑<br> A 在下标 1</p><p>左边 <code>B</code> → 左子树<br> 右边 <code>D C</code> → 右子树</p><p>这样就切出来了。</p><hr><h1 id="🚀-3-那为什么一定要用-map？"><a href="#🚀-3-那为什么一定要用-map？" class="headerlink" title="🚀 3. 那为什么一定要用 map？"></a>🚀 <strong>3. 那为什么一定要用 map？</strong></h1><p>因为我要知道：</p><blockquote><p>字母 A 在中序字符串里是第几位？</p></blockquote><p>你可以用 for 循环扫：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; in.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (in[i] == root) k = i;</span><br></pre></td></tr></table></figure><p>但更聪明的是：</p><p>我先建一个<strong>查表</strong>（map）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pos[<span class="string">&#x27;B&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">pos[<span class="string">&#x27;A&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">pos[<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">pos[<span class="string">&#x27;C&#x27;</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这样我要找位置用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = pos[root];</span><br></pre></td></tr></table></figure><p>一查就知道，非常快、非常干净。</p><hr><h1 id="🚀-4-为什么用递归-build？"><a href="#🚀-4-为什么用递归-build？" class="headerlink" title="🚀 4. 为什么用递归 build？"></a>🚀 <strong>4. 为什么用递归 build？</strong></h1><p>因为二叉树天然就是递归结构：</p><ul><li>当前根节点确定了</li><li>左子树也按照相同逻辑构建</li><li>右子树也一样</li></ul><p>递归适合干“重复但规模缩小”的事。</p><hr><h1 id="🚀-5-核心代码（逐行傻瓜讲解）"><a href="#🚀-5-核心代码（逐行傻瓜讲解）" class="headerlink" title="🚀 5. 核心代码（逐行傻瓜讲解）"></a>🚀 <strong>5. 核心代码（逐行傻瓜讲解）</strong></h1><p>我把代码拆开讲，你秒懂：</p><hr><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a><strong>读取输入</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; in &gt;&gt; post;</span><br></pre></td></tr></table></figure><p>读两个字符串，中序和后序。</p><hr><h2 id="建立-map：每个字符在中序中的位置"><a href="#建立-map：每个字符在中序中的位置" class="headerlink" title="建立 map：每个字符在中序中的位置"></a><strong>建立 map：每个字符在中序中的位置</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; in.<span class="built_in">size</span>(); i++)</span><br><span class="line">    pos[in[i]] = i;</span><br></pre></td></tr></table></figure><p>以后我要查 A 在哪里，只要：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pos[&#x27;A&#x27;]</span><br></pre></td></tr></table></figure><hr><h2 id="build-函数：递归构建先序字符串"><a href="#build-函数：递归构建先序字符串" class="headerlink" title="build 函数：递归构建先序字符串"></a><strong>build 函数：递归构建先序字符串</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> inL, <span class="type">int</span> inR, <span class="type">int</span> postL, <span class="type">int</span> postR)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>表示我们现在要处理的<strong>中序区间</strong> 和 <strong>后序区间</strong>是什么。</p><hr><h2 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a><strong>终止条件</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inL &gt; inR) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>左边超过右边，一棵空树，啥都别干。</p><hr><h2 id="后序最后一个一定是根"><a href="#后序最后一个一定是根" class="headerlink" title="后序最后一个一定是根"></a><strong>后序最后一个一定是根</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> root = post[postR];</span><br></pre></td></tr></table></figure><p>比如后序是 <code>BDCA</code>，最后的 <code>A</code> 是根。</p><hr><h2 id="先序输出顺序：根在最前"><a href="#先序输出顺序：根在最前" class="headerlink" title="先序输出顺序：根在最前"></a><strong>先序输出顺序：根在最前</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre.<span class="built_in">push_back</span>(root);</span><br></pre></td></tr></table></figure><p>先序是：根 左 右<br> 所以先把根输出出去。</p><hr><h2 id="找根在中序的位置"><a href="#找根在中序的位置" class="headerlink" title="找根在中序的位置"></a><strong>找根在中序的位置</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k = pos[root];</span><br></pre></td></tr></table></figure><p>pos 是我们提前做好查表，用 map 查一次就出来。</p><hr><h2 id="计算左子树的大小"><a href="#计算左子树的大小" class="headerlink" title="计算左子树的大小"></a><strong>计算左子树的大小</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftSize = k - inL;</span><br></pre></td></tr></table></figure><p>比如中序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inL ... 左子树 ... k(root) ... 右子树 ... inR</span><br></pre></td></tr></table></figure><p>很自然 leftSize = 左子树长度。</p><hr><h2 id="递归构建左子树"><a href="#递归构建左子树" class="headerlink" title="递归构建左子树"></a><strong>递归构建左子树</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">build</span>(inL, k - <span class="number">1</span>, postL, postL + leftSize - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>中序：左边部分<br> 后序：左边部分</p><hr><h2 id="递归构建右子树"><a href="#递归构建右子树" class="headerlink" title="递归构建右子树"></a><strong>递归构建右子树</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">build</span>(k + <span class="number">1</span>, inR, postL + leftSize, postR - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>右子树的中序和后序区间自己算出来的。</p><hr><h1 id="🚀-6-完整源码（含解释版）"><a href="#🚀-6-完整源码（含解释版）" class="headerlink" title="🚀 6. 完整源码（含解释版）"></a>🚀 <strong>6. 完整源码（含解释版）</strong></h1><p>下面是你需要的完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string in, post;    <span class="comment">// 输入：中序和后序</span></span><br><span class="line">string pre;         <span class="comment">// 输出：先序</span></span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; pos; <span class="comment">// 记录每个节点在中序中的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> inL, <span class="type">int</span> inR, <span class="type">int</span> postL, <span class="type">int</span> postR)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空区间，返回</span></span><br><span class="line">    <span class="keyword">if</span> (inL &gt; inR) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序最后一个是根</span></span><br><span class="line">    <span class="type">char</span> root = post[postR];</span><br><span class="line">    pre.<span class="built_in">push_back</span>(root); <span class="comment">// 先序先输出根</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根在中序中的下标</span></span><br><span class="line">    <span class="type">int</span> k = pos[root];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树大小 = 中序左半长度</span></span><br><span class="line">    <span class="type">int</span> leftSize = k - inL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建左子树</span></span><br><span class="line">    <span class="built_in">build</span>(inL, k - <span class="number">1</span>, postL, postL + leftSize - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建右子树</span></span><br><span class="line">    <span class="built_in">build</span>(k + <span class="number">1</span>, inR, postL + leftSize, postR - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; in &gt;&gt; post;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建表：O(n) 记录每个字符在中序里的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; in.<span class="built_in">size</span>(); i++)</span><br><span class="line">        pos[in[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">0</span>, in.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>, post.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; pre &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="举例论证"><a href="#举例论证" class="headerlink" title="举例论证"></a>举例论证</h1><h2 id="✅-例子-1：题目同类型（简单对称）"><a href="#✅-例子-1：题目同类型（简单对称）" class="headerlink" title="✅ 例子 1：题目同类型（简单对称）"></a>✅ <strong>例子 1：题目同类型（简单对称）</strong></h2><p>中序：<code>BADC</code><br> 后序：<code>BDCA</code></p><h2 id="步骤-1：后序最后一个是根"><a href="#步骤-1：后序最后一个是根" class="headerlink" title="步骤 1：后序最后一个是根"></a><strong>步骤 1：后序最后一个是根</strong></h2><ul><li>根 = <code>A</code></li></ul><p>中序定位 <code>A</code>：<br> <code>B A D C</code><br> ↑<br> 位置 index = 1</p><p>左子树中序：<code>B</code><br> 右子树中序：<code>D C</code></p><p>后序拆分：</p><p>左子树后序：<code>B</code><br> 右子树后序：<code>D C</code></p><hr><h2 id="步骤-2：递归左子树"><a href="#步骤-2：递归左子树" class="headerlink" title="步骤 2：递归左子树"></a><strong>步骤 2：递归左子树</strong></h2><p>中序：<code>B</code><br> 后序：<code>B</code></p><p>后序最后一个 → 根 = <code>B</code><br> 没有左右子树。</p><hr><h2 id="步骤-3：递归右子树"><a href="#步骤-3：递归右子树" class="headerlink" title="步骤 3：递归右子树"></a><strong>步骤 3：递归右子树</strong></h2><p>中序：<code>D C</code><br> 后序：<code>D C</code></p><p>根 = <code>C</code></p><p>中序定位 <code>C</code>：<br> <code>D C</code><br> ↑<br> index = 1</p><p>左：<code>D</code><br> 右：空</p><p>左子树后序：<code>D</code><br> 右子树后序：空</p><hr><h2 id="步骤-4：构建右子树的左子树"><a href="#步骤-4：构建右子树的左子树" class="headerlink" title="步骤 4：构建右子树的左子树"></a><strong>步骤 4：构建右子树的左子树</strong></h2><p>中序：<code>D</code><br> 后序：<code>D</code></p><p>根 = <code>D</code>，无左右子树。</p><hr><h2 id="🌟-最终先序输出顺序："><a href="#🌟-最终先序输出顺序：" class="headerlink" title="🌟 最终先序输出顺序："></a>🌟 最终先序输出顺序：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A B C D</span><br></pre></td></tr></table></figure><p>完全正确。</p><hr><h2 id="✅-例子-2"><a href="#✅-例子-2" class="headerlink" title="✅ **例子 2:"></a>✅ **例子 2:</h2><p>例如一棵向左的链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    D</span><br><span class="line">   /</span><br><span class="line">  C</span><br><span class="line"> /</span><br><span class="line">B</span><br><span class="line">/</span><br><span class="line">A</span><br></pre></td></tr></table></figure><p>中序（左 根 右）：<code>ABCD</code><br> 后序（左 右 根）：<code>ABCD</code></p><h3 id="模拟构建"><a href="#模拟构建" class="headerlink" title="模拟构建"></a><strong>模拟构建</strong></h3><ol><li>后序最后 → 根 = <code>D</code><br> 中序中 <code>ABC | D</code></li><li>左子树：中序 <code>ABC</code>，后序 <code>ABC</code></li><li>再取根 = <code>C</code></li><li>左子树：<code>AB</code></li><li>根 = <code>B</code></li><li>左子树：<code>A</code></li><li>根 = <code>A</code></li></ol><p>先序（根 左 右）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D C B A</span><br></pre></td></tr></table></figure><p>验证：完全正确。</p><hr><h2 id="✅-例子-3：所有节点都在右边（链式右树）"><a href="#✅-例子-3：所有节点都在右边（链式右树）" class="headerlink" title="✅ 例子 3：所有节点都在右边（链式右树）"></a>✅ <strong>例子 3：所有节点都在右边（链式右树）</strong></h2><p>结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"> \</span><br><span class="line">  B</span><br><span class="line">   \</span><br><span class="line">    C</span><br><span class="line">     \</span><br><span class="line">      D</span><br></pre></td></tr></table></figure><p>中序：<code>ABCD</code><br> 后序：<code>BCDA</code></p><h3 id="模拟构建-1"><a href="#模拟构建-1" class="headerlink" title="模拟构建"></a><strong>模拟构建</strong></h3><ol><li>根 = <code>D</code><br> 中序：<code>ABC | D</code> → 右子树是 ABC</li><li>对右子树：<ul><li>后序：<code>B C A</code></li><li>根 = <code>A</code></li></ul></li><li>中序：<code>B C | A</code></li><li>对右子树：<ul><li>后序：<code>B C</code></li><li>根 = <code>C</code></li></ul></li><li>中序：<code>B | C</code></li><li>左子树：<code>B</code></li></ol><p>先序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D A C B</span><br></pre></td></tr></table></figure><p>完全正确。</p><hr><h2 id="✅-例子-4：典型杂乱结构"><a href="#✅-例子-4：典型杂乱结构" class="headerlink" title="✅ 例子 4：典型杂乱结构"></a>✅ <strong>例子 4：典型杂乱结构</strong></h2><p>树如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  F</span><br><span class="line"> / \</span><br><span class="line">B   G</span><br><span class="line"> \   \</span><br><span class="line">  D   I</span><br></pre></td></tr></table></figure><h3 id="手算遍历结果"><a href="#手算遍历结果" class="headerlink" title="手算遍历结果"></a><strong>手算遍历结果</strong></h3><p>中序（左 根 右）：</p><p>左子树(B D) → <code>B D</code><br> 根 F<br> 右子树(G I) → <code>G I</code></p><p>中序 = <code>B D F G I</code></p><p>后序（左 右 根）：</p><p>左子树(B D) → <code>D B</code><br> 右子树(G I) → <code>I G</code><br> 根 F</p><p>后序 = <code>D B I G F</code></p><hr><h3 id="模拟重建"><a href="#模拟重建" class="headerlink" title="模拟重建"></a><strong>模拟重建</strong></h3><p>给你中序：<code>BDFGI</code><br> 后序：<code>DBIGF</code></p><h4 id="第一次："><a href="#第一次：" class="headerlink" title="第一次："></a>第一次：</h4><p>根 = <code>F</code><br> 中序分为：<code>BD | F | GI</code></p><h4 id="左子树："><a href="#左子树：" class="headerlink" title="左子树："></a>左子树：</h4><p>中序：<code>BD</code><br> 后序：<code>DB</code><br> 根 = <code>B</code><br> 中序 <code>| B | D</code> → 右子树是 <code>D</code></p><h4 id="右子树："><a href="#右子树：" class="headerlink" title="右子树："></a>右子树：</h4><p>中序：<code>GI</code><br> 后序：<code>IG</code><br> 根 = <code>G</code><br> 右子树 = <code>I</code></p><hr><h3 id="先序输出："><a href="#先序输出：" class="headerlink" title="先序输出："></a><strong>先序输出</strong>：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F B D G I</span><br></pre></td></tr></table></figure><p>符合真实结构。</p><hr><h1 id="🔥-你现在要记住的唯一原则："><a href="#🔥-你现在要记住的唯一原则：" class="headerlink" title="🔥 你现在要记住的唯一原则："></a>🔥 <strong>你现在要记住的唯一原则：</strong></h1><blockquote><p><strong>后序最后一个字符一定是根；在中序中找到根的位置，就能把左右子树精确切开。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法类 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的恋爱日记10.30</title>
      <link href="/posts/97980273.html"/>
      <url>/posts/97980273.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="好棒哦明天就是周五-可以睡很久啦"><a href="#好棒哦明天就是周五-可以睡很久啦" class="headerlink" title="好棒哦明天就是周五 可以睡很久啦!!!"></a>好棒哦明天就是周五 可以睡很久啦!!!</h1><h3 id="今天过得还好-虽然说确实是发病了-感觉脑子里有点波在震荡www-我是不是中了毒电波-不是"><a href="#今天过得还好-虽然说确实是发病了-感觉脑子里有点波在震荡www-我是不是中了毒电波-不是" class="headerlink" title="今天过得还好 虽然说确实是发病了 感觉脑子里有点波在震荡www 我是不是中了毒电波(不是"></a>今天过得还好 虽然说确实是发病了 感觉脑子里有点波在震荡www 我是不是中了毒电波(不是</h3><p>其余的日常都很简短 但是今天脑子里一直有一个很强烈的想法</p><h1 id="就是超级想我的宝宝想死了想到快疯掉"><a href="#就是超级想我的宝宝想死了想到快疯掉" class="headerlink" title="就是超级想我的宝宝想死了想到快疯掉!!!!!"></a>就是超级想我的宝宝想死了想到快疯掉!!!!!</h1><h3 id="呜呜呜好像让我的宝宝身体好起来-超级想哦-每天都想-不想让他不好-能不能锁住他的喉咙-把他绑起来-这样他就不会走了-当然她本身也不会走-我就是怕嘛我就是好想我的宝宝能够快快好起来-不管怎么样好起来就好"><a href="#呜呜呜好像让我的宝宝身体好起来-超级想哦-每天都想-不想让他不好-能不能锁住他的喉咙-把他绑起来-这样他就不会走了-当然她本身也不会走-我就是怕嘛我就是好想我的宝宝能够快快好起来-不管怎么样好起来就好" class="headerlink" title="呜呜呜好像让我的宝宝身体好起来 超级想哦 每天都想 不想让他不好 能不能锁住他的喉咙 把他绑起来 这样他就不会走了 当然她本身也不会走 我就是怕嘛我就是好想我的宝宝能够快快好起来 不管怎么样好起来就好 !!!"></a>呜呜呜好像让我的宝宝身体好起来 超级想哦 每天都想 不想让他不好 能不能锁住他的喉咙 把他绑起来 这样他就不会走了 当然她本身也不会走 我就是怕嘛我就是好想我的宝宝能够快快好起来 不管怎么样好起来就好 !!!</h3><h1 id="呜呜呜宝宝快好起来qwq"><a href="#呜呜呜宝宝快好起来qwq" class="headerlink" title="呜呜呜宝宝快好起来qwq"></a>呜呜呜宝宝快好起来qwq</h1><h4 id="这篇日记好抽象-我就喜欢抽象的-正好作为开端-但是没办法-今天就是超级想超级想我的宝宝呜呜呜"><a href="#这篇日记好抽象-我就喜欢抽象的-正好作为开端-但是没办法-今天就是超级想超级想我的宝宝呜呜呜" class="headerlink" title="这篇日记好抽象 我就喜欢抽象的 正好作为开端 但是没办法 今天就是超级想超级想我的宝宝呜呜呜"></a>这篇日记好抽象 我就喜欢抽象的 正好作为开端 但是没办法 今天就是超级想超级想我的宝宝呜呜呜</h4><h1 id="希望我的宝宝好好的-我们一直好好的-我爱你-爱死你了-要把全世界送给你"><a href="#希望我的宝宝好好的-我们一直好好的-我爱你-爱死你了-要把全世界送给你" class="headerlink" title="希望我的宝宝好好的 我们一直好好的 我爱你 爱死你了 要把全世界送给你!!!"></a>希望我的宝宝好好的 我们一直好好的 我爱你 爱死你了 要把全世界送给你!!!</h1><h1 id="爱你哦"><a href="#爱你哦" class="headerlink" title="爱你哦"></a>爱你哦</h1><h1 id="（づ￣3￣）づ╭❤～Mua"><a href="#（づ￣3￣）づ╭❤～Mua" class="headerlink" title="（づ￣3￣）づ╭❤～Mua!!!"></a>（づ￣3￣）づ╭❤～Mua!!!</h1>]]></content>
      
      
      <categories>
          
          <category> 恋爱足迹 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星酱 </tag>
            
            <tag> 恋爱 </tag>
            
            <tag> 地雷 </tag>
            
            <tag> 极度爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于素数的一系列解决办法</title>
      <link href="/posts/90a8f6e6.html"/>
      <url>/posts/90a8f6e6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="🚀-排行总结（按实际运行速度和复杂度综合）"><a href="#🚀-排行总结（按实际运行速度和复杂度综合）" class="headerlink" title="🚀 排行总结（按实际运行速度和复杂度综合）"></a>🚀 排行总结（按实际运行速度和复杂度综合）</h2><div class="table-container"><table><thead><tr><th>排名</th><th>名称</th><th>理论复杂度</th><th>实际速度</th><th>特点</th></tr></thead><tbody><tr><td>🥇 1</td><td><strong>线性筛（Euler Sieve）</strong></td><td>O(n)</td><td>⚡⚡⚡⚡⚡</td><td>每个合数只标一次，最干净最快</td></tr><tr><td>🥈 2</td><td><strong>快速埃式（奇数筛/位压缩版）</strong></td><td>O(n log log n)</td><td>⚡⚡⚡⚡</td><td>节省空间、跳偶数</td></tr><tr><td>🥉 3</td><td><strong>标准埃式筛（Eratosthenes）</strong></td><td>O(n log log n)</td><td>⚡⚡⚡</td><td>简单、稳健，入门首选</td></tr><tr><td>🪨 4</td><td><strong>试除法（6k±1 或暴力）</strong></td><td>O(n√n)</td><td>🐢</td><td>太慢，只适合单个数判素</td></tr></tbody></table></div><hr><h2 id="💬-总结一句人话："><a href="#💬-总结一句人话：" class="headerlink" title="💬 总结一句人话："></a>💬 总结一句人话：</h2><ul><li><strong>只想快速写完题 → 标准埃式筛。</strong></li><li><strong>想搞高效算法 / 竞赛用 → 线性筛。</strong></li><li><strong>只判断一个数是不是素数 → 6k±1试除法。</strong></li><li><strong>还用暴力除法 → 你在浪费电。</strong></li></ul><p>上述就是筛法的一个排行 <strong>试除法</strong>和<strong>暴力除法</strong>我们这里不涉及 <strong>因为一点意义都没有!!!!!</strong></p><h1 id="埃式筛-也就是标准筛"><a href="#埃式筛-也就是标准筛" class="headerlink" title="埃式筛(也就是标准筛)"></a>埃式筛(也就是标准筛)</h1><p>好，那我用最“人话”的方式教你学会埃式筛。就当我们在教一个刚学会 <code>for</code> 循环的小孩。<br> 我们一步一念，绝对不会跳。</p><hr><h2 id="🧠-你要干什么？"><a href="#🧠-你要干什么？" class="headerlink" title="🧠 你要干什么？"></a>🧠 你要干什么？</h2><p>找出 1 到 200 里所有的素数。<br> 素数就是——只能被 1 和自己整除的数，比如：2, 3, 5, 7, 11…</p><hr><h2 id="🧩-第一步：准备一张表"><a href="#🧩-第一步：准备一张表" class="headerlink" title="🧩 第一步：准备一张表"></a>🧩 第一步：准备一张表</h2><p>想象一张表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编号： 0  1  2  3  4  5  6  7  8  9  10 ... 200</span><br><span class="line">内容： 否 否 是 是 是 是 是 是 是 是 ...</span><br></pre></td></tr></table></figure><ul><li>我们先假设所有数字都是素数，用 <code>1</code> 表示“是素数”，用 <code>0</code> 表示“不是”。</li><li>但是我们知道 0 和 1 不是素数，所以把它俩设为 <code>0</code>。</li></ul><p>C 语言实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> is_prime[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">    is_prime[i] = <span class="number">1</span>;  <span class="comment">// 先都当作是素数</span></span><br><span class="line">&#125;</span><br><span class="line">is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 0和1不是素数</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第二步：从-2-开始圈掉倍数"><a href="#🧩-第二步：从-2-开始圈掉倍数" class="headerlink" title="🧩 第二步：从 2 开始圈掉倍数"></a>🧩 第二步：从 2 开始圈掉倍数</h2><p>我们从第一个素数 2 开始。<br> 2 的倍数（除了 2 本身）都不是素数，比如 4、6、8、10……<br> 所以我们把这些位置标成 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * <span class="number">2</span>; j &lt;= <span class="number">200</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    is_prime[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第三步：找下一个没被划掉的数"><a href="#🧩-第三步：找下一个没被划掉的数" class="headerlink" title="🧩 第三步：找下一个没被划掉的数"></a>🧩 第三步：找下一个没被划掉的数</h2><p>划完 2 的倍数后，表里下一个没被划掉的数是 3。<br> 那 3 就是下一个素数。<br> 再把 3 的倍数（9, 12, 15, 18…）划掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span> * <span class="number">3</span>; j &lt;= <span class="number">200</span>; j += <span class="number">3</span>) &#123;</span><br><span class="line">    is_prime[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第四步：重复这个过程"><a href="#🧩-第四步：重复这个过程" class="headerlink" title="🧩 第四步：重复这个过程"></a>🧩 第四步：重复这个过程</h2><p>继续往后找：</p><ul><li>下一个没被划掉的是 5 → 划掉 25, 30, 35…</li><li>再下一个是 7 → 划掉 49, 56, 63…</li><li>一直循环，直到 √200 ≈ 14 为止。</li></ul><p>完整循环写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>) &#123;  <span class="comment">// 如果这个数还没被划掉</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= <span class="number">200</span>; j += i) &#123;</span><br><span class="line">            is_prime[j] = <span class="number">0</span>; <span class="comment">// 划掉它的倍数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🧩-第五步：打印结果"><a href="#🧩-第五步：打印结果" class="headerlink" title="🧩 第五步：打印结果"></a>🧩 第五步：打印结果</h2><p>最后，把还没被划掉（值为1）的数都输出，就是所有素数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="✨-最终完整代码"><a href="#✨-最终完整代码" class="headerlink" title="✨ 最终完整代码"></a>✨ 最终完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> is_prime[<span class="number">201</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">        is_prime[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//给他们带上素数的棋子</span></span><br><span class="line">    is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//这两个不是素数 直接抬走</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">200</span><span class="comment">/*这里这样写就是可以降低重复率*/</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>) &#123;<span class="comment">//先给那些标称素数的进行一个验证</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= <span class="number">200</span>; j += i) &#123;</span><br><span class="line">                is_prime[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200以内的素数：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🪄-你可以这么理解它："><a href="#🪄-你可以这么理解它：" class="headerlink" title="🪄 你可以这么理解它："></a>🪄 你可以这么理解它：</h2><ul><li><code>is_prime</code> 就是一堆小旗子。</li><li>你从 2 开始，一个一个数过去。</li><li>每当遇到一个还竖着的小旗（说明它是素数），<br> 你就拿着大笔刷去把它的倍数“涂掉”。</li><li>最后剩下没被涂掉的，都是素数。</li></ul><h1 id="快筛"><a href="#快筛" class="headerlink" title="快筛"></a>快筛</h1><h2 id="🧠-先搞清楚："><a href="#🧠-先搞清楚：" class="headerlink" title="🧠 先搞清楚："></a>🧠 先搞清楚：</h2><p>“快筛”不是新算法，它就是普通埃式筛的小升级：<br> 👉 不去处理所有偶数（因为除了 2，偶数全是合数）。<br> 👉 所以我们只管奇数，少干一半活。</p><p>你可以理解成：</p><blockquote><p>原本你要清理 200 个房间，现在只清理奇数号的那 100 个，速度自然翻倍。</p></blockquote><hr><h2 id="🧩-我们来一步步写："><a href="#🧩-我们来一步步写：" class="headerlink" title="🧩 我们来一步步写："></a>🧩 我们来一步步写：</h2><h3 id="第一步：准备数组"><a href="#第一步：准备数组" class="headerlink" title="第一步：准备数组"></a>第一步：准备数组</h3><p>我们只存<strong>奇数</strong>的状态。<br> 下标 <code>i</code> 代表数字 <code>2*i + 1</code>。<br> 比如：</p><div class="table-container"><table><thead><tr><th>i</th><th>表示的数字</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>5</td></tr><tr><td>3</td><td>7</td></tr><tr><td>4</td><td>9</td></tr><tr><td>…</td><td>…</td></tr></tbody></table></div><p>C代码里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> size = (N - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 表示到N的奇数数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> is_prime[size];</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime)); <span class="comment">// 全部假设是素数</span></span><br><span class="line">    is_prime[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 1 不是素数</span></span><br></pre></td></tr></table></figure><hr><h3 id="第二步：开始筛"><a href="#第二步：开始筛" class="headerlink" title="第二步：开始筛"></a>第二步：开始筛</h3><p>我们要从 3 开始（下标 1），只筛奇数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">2</span>*i + <span class="number">1</span>) * (<span class="number">2</span>*i + <span class="number">1</span>) &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">2</span>*i + <span class="number">1</span>; <span class="comment">// 还原真实数字</span></span><br><span class="line">        <span class="comment">// 从 p*p 开始划去奇数倍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = (p*p - <span class="number">1</span>)/<span class="number">2</span>; j &lt; size; j += p) &#123;</span><br><span class="line">            is_prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑解释：</p><ul><li>从第一个奇数素数 3 开始；</li><li>不用标偶数倍，比如 6、12、18；</li><li>只标奇数倍，比如 9、15、21；</li><li>所以只动一半的数，速度翻倍。</li></ul><hr><h3 id="第三步：输出结果"><a href="#第三步：输出结果" class="headerlink" title="第三步：输出结果"></a>第三步：输出结果</h3><p>别忘了 2 是唯一的偶数素数，要单独打印。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200以内的素数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="📜-最终完整代码："><a href="#📜-最终完整代码：" class="headerlink" title="📜 最终完整代码："></a>📜 最终完整代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> size = (N - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;        <span class="comment">// 奇数数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> is_prime[size];</span><br><span class="line">    <span class="built_in">memset</span>(is_prime, <span class="number">1</span>, <span class="keyword">sizeof</span>(is_prime));</span><br><span class="line">    is_prime[<span class="number">0</span>] = <span class="number">0</span>;                   <span class="comment">// 1 不是素数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (<span class="number">2</span>*i + <span class="number">1</span>) * (<span class="number">2</span>*i + <span class="number">1</span>) &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = (p*p - <span class="number">1</span>)/<span class="number">2</span>; j &lt; size; j += p)</span><br><span class="line">                is_prime[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;200以内的素数：\n2 &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="number">2</span>*i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-傻瓜总结"><a href="#🎯-傻瓜总结" class="headerlink" title="🎯 傻瓜总结"></a>🎯 傻瓜总结</h2><div class="table-container"><table><thead><tr><th>操作</th><th>意思</th><th>为什么这样做</th></tr></thead><tbody><tr><td>只存奇数</td><td>少一半空间</td><td>偶数没必要筛</td></tr><tr><td>从 p*p 开始</td><td>前面的倍数早被更小素数划了</td><td>省事</td></tr><tr><td>每次加 p</td><td>跳到下一个奇数倍</td><td>不碰偶数</td></tr><tr><td>单独打印 2</td><td>唯一的偶数素数</td><td>特殊待遇</td></tr></tbody></table></div><hr><h2 id="🧮-运行结果："><a href="#🧮-运行结果：" class="headerlink" title="🧮 运行结果："></a>🧮 运行结果：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200以内的素数：</span><br><span class="line">2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199</span><br></pre></td></tr></table></figure><hr><p>一句话记住：</p><blockquote><p>“快筛”就是埃式筛 + 跳偶数。<br> 做的事一样，干得更快。</p></blockquote><h1 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h1><h2 id="🍎-故事开场："><a href="#🍎-故事开场：" class="headerlink" title="🍎 故事开场："></a>🍎 故事开场：</h2><p>我们要从 1 数到 20，找出哪些数是素数。<br> 你是“质数班长”，手里拿一支笔，要在黑板上划掉不是素数的数字。</p><hr><h2 id="🧩-规则很简单："><a href="#🧩-规则很简单：" class="headerlink" title="🧩 规则很简单："></a>🧩 规则很简单：</h2><ol><li>从 2 开始，一个个往上看。</li><li>如果这个数还没被划掉 → 它就是素数。</li><li>然后你拿“你已经认识的所有素数”去乘它。</li><li>每乘出来一个结果，就把那个结果划掉。</li><li>一旦发现这个素数整除了你当前的数字，就停下来，不划更多。</li></ol><hr><h2 id="👀-举例说明："><a href="#👀-举例说明：" class="headerlink" title="👀 举例说明："></a>👀 举例说明：</h2><h3 id="第一个数字：2"><a href="#第一个数字：2" class="headerlink" title="第一个数字：2"></a>第一个数字：2</h3><ul><li>没被划掉 → 是素数。</li><li>素数表：<code>[2]</code></li><li>拿 2 去乘它自己：<code>2*2=4</code> → 划掉 4。</li><li>因为 2%2==0 → 停。</li></ul><hr><h3 id="下一个数字：3"><a href="#下一个数字：3" class="headerlink" title="下一个数字：3"></a>下一个数字：3</h3><ul><li>没被划 → 是素数。</li><li>素数表：<code>[2, 3]</code></li><li>用 2 去乘：<code>3*2=6</code> → 划掉 6。<br> 因为 3%2!=0，继续；</li><li>用 3 去乘：<code>3*3=9</code> → 划掉 9。<br> 因为 3%3==0，停。</li></ul><hr><h3 id="下一个数字：4"><a href="#下一个数字：4" class="headerlink" title="下一个数字：4"></a>下一个数字：4</h3><ul><li>4 已经被划掉 → 跳过，不是素数。</li><li>但我们也要拿 2 去乘：<br> <code>4*2=8</code> → 划掉。<br> 因为 4%2==0 → 停。</li></ul><hr><h3 id="继续到-5："><a href="#继续到-5：" class="headerlink" title="继续到 5："></a>继续到 5：</h3><ul><li>没被划 → 是素数。</li><li>素数表 <code>[2,3,5]</code></li><li>乘：<br> <code>5*2=10</code> → 划掉<br> <code>5*3=15</code> → 划掉<br> <code>5*5=25</code> 超出范围 → 停</li></ul><hr><h3 id="6："><a href="#6：" class="headerlink" title="6："></a>6：</h3><ul><li>已被标 → 合数</li><li>拿 2 乘：<code>6*2=12</code> → 划掉</li><li>因为 6%2==0 → 停</li></ul><p>就这样一轮一轮下去，每个数字只被“第一个能整除它的质数”划一次。</p><hr><h2 id="🧮-结果："><a href="#🧮-结果：" class="headerlink" title="🧮 结果："></a>🧮 结果：</h2><p>没被划掉的数字 = 素数。<br> 对 1~20 来说：<br> <code>2, 3, 5, 7, 11, 13, 17, 19</code></p><hr><h2 id="💻-C语言实现（超级傻瓜版）"><a href="#💻-C语言实现（超级傻瓜版）" class="headerlink" title="💻 C语言实现（超级傻瓜版）"></a>💻 C语言实现（超级傻瓜版）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    const int N = 200;</span><br><span class="line">    int is_comp[N + 1];  // 0 表示还没划掉，1 表示已经划掉</span><br><span class="line">    int primes[N + 1];   // 存所有素数</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    memset(is_comp, 0, sizeof(is_comp));</span><br><span class="line"></span><br><span class="line">    for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">        if (!is_comp[i]) &#123;</span><br><span class="line">            primes[count++] = i;   // 这个数没被划掉，是素数</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">            int p = primes[j];</span><br><span class="line">            if (i * p &gt; N) break;  // 超出范围就别划了</span><br><span class="line">            is_comp[i * p] = 1;    // 划掉这个合数</span><br><span class="line">            if (i % p == 0) break; // 一旦被这个质数整除，就停</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;200以内的素数：\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, primes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-一句话总结"><a href="#🎯-一句话总结" class="headerlink" title="🎯 一句话总结"></a>🎯 一句话总结</h2><div class="table-container"><table><thead><tr><th>版本</th><th>规则</th><th>重复划吗</th><th>速度</th></tr></thead><tbody><tr><td>暴力试除</td><td>一个个除</td><td>很多</td><td>最慢</td></tr><tr><td>埃式筛</td><td>一个素数划所有倍数</td><td>有点重复</td><td>快</td></tr><tr><td>线性筛</td><td>每个合数只被最小质因子划一次</td><td>不重复</td><td>最快</td></tr></tbody></table></div><hr><p>如果你能记住一句话，你就懂线性筛了：</p><blockquote><p><strong>“每个数只让它的第一个质因子出手一次。”</strong></p></blockquote><p>要不要我帮你画成一张表格（比如1到30）告诉你每个数是被谁“干掉”的？那张表会让你彻底看懂原理。</p><h5 id="您说："><a href="#您说：" class="headerlink" title="您说："></a>您说：</h5><p>我理解他的逻辑但是我不理解为什么是这么做的</p><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常好，这个问题说明你已经不只是“会抄算法”，而是真的想<strong>理解它的逻辑根源</strong>。<br> 我来用<strong>非常通俗的方式</strong>告诉你，为什么线性筛要“这么做”，而且“这么做就对了”。</p><hr><h2 id="🧠-一句话先定调"><a href="#🧠-一句话先定调" class="headerlink" title="🧠 一句话先定调"></a>🧠 一句话先定调</h2><p>线性筛的那句核心代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (i % p == 0) break;</span><br></pre></td></tr></table></figure><p>其实就是在控制——<br> 👉 每个合数，只被“它的最小质因子”负责一次。<br> 这就是整个算法的灵魂。<br> 下面我分成三个阶段帮你想透它。</p><hr><h2 id="🧩-一、回忆一下埃式筛的问题"><a href="#🧩-一、回忆一下埃式筛的问题" class="headerlink" title="🧩 一、回忆一下埃式筛的问题"></a>🧩 一、回忆一下埃式筛的问题</h2><p>埃式筛干的活是：</p><ul><li>每发现一个素数，就去划它的倍数。</li><li>比如 12 会被谁划？<ul><li>被 2 划一次（2×6）</li><li>被 3 又划一次（3×4）</li><li>被 4 还可能划（虽然4不是素数）</li></ul></li></ul><p>这就叫“<strong>重复劳动</strong>”。<br> 埃式筛虽然已经很快，但它对每个合数都可能划很多次。</p><hr><h2 id="🧩-二、那我们能不能让每个合数只被“一个人”划？"><a href="#🧩-二、那我们能不能让每个合数只被“一个人”划？" class="headerlink" title="🧩 二、那我们能不能让每个合数只被“一个人”划？"></a>🧩 二、那我们能不能让每个合数只被“一个人”划？</h2><p>我们希望：</p><ul><li>12 只被 2 处理一次；</li><li>18 只被 3 处理一次；</li><li>25 只被 5 处理一次。</li></ul><p>那怎么办？<br> 我们规定：</p><blockquote><p><strong>一个合数只能被它的最小质因子负责。</strong></p></blockquote><hr><h2 id="🧩-三、算法的关键思想：i-×-p"><a href="#🧩-三、算法的关键思想：i-×-p" class="headerlink" title="🧩 三、算法的关键思想：i × p"></a>🧩 三、算法的关键思想：i × p</h2><p>我们从小到大枚举 i，然后拿素数表里的质数去乘它。</p><p>每当我们在循环中计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i * p</span><br></pre></td></tr></table></figure><p>这个结果就是一个合数。<br> <strong>那这个合数的最小质因子是谁？</strong><br> 答案：一定是 <code>p</code>。</p><p>为什么？看下面的分析。</p><hr><h3 id="🔍-情况1：i-没有被-p-整除"><a href="#🔍-情况1：i-没有被-p-整除" class="headerlink" title="🔍 情况1：i 没有被 p 整除"></a>🔍 情况1：i 没有被 p 整除</h3><p>比如 i = 9, p = 2。<br> → i * p = 18。<br> 18 的质因子有 2, 3, 6…<br> 最小质因子确实是 2。✅<br> 说明标记 18 的动作是正确的。</p><hr><h3 id="🔍-情况2：i-能被-p-整除"><a href="#🔍-情况2：i-能被-p-整除" class="headerlink" title="🔍 情况2：i 能被 p 整除"></a>🔍 情况2：i 能被 p 整除</h3><p>比如 i = 6, p = 2。<br> → i * p = 12。<br> 12 的质因子里，最小质因子也是 2。✅<br> 所以标记 12 这次没问题。</p><p>但再往后如果我用 p=3，再标一次：<br> i = 6, p = 3 → i*p = 18。<br> 18 的最小质因子其实是 2，不是 3。<br> 那 18 已经在“2”那轮被标过了，<br> 这次再标就是重复劳动。❌</p><p>所以，我们一旦发现 i 已经被 p 整除（<code>i % p == 0</code>），<br> 我们就知道：</p><blockquote><p>“再往后的质数都会比 p 大，它们标出来的乘积 i<em>p’ 的最小质因子仍然是 p。”<br> 于是我们<em>*立即停下</em></em>。</p></blockquote><hr><h2 id="⚙️-用人话总结整个逻辑链"><a href="#⚙️-用人话总结整个逻辑链" class="headerlink" title="⚙️ 用人话总结整个逻辑链"></a>⚙️ 用人话总结整个逻辑链</h2><div class="table-container"><table><thead><tr><th>阶段</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>我们要标出所有合数。</td></tr><tr><td>2</td><td>每个合数应该只被它的最小质因子标一次。</td></tr><tr><td>3</td><td>枚举 i，并用所有质数 p 去乘 i。</td></tr><tr><td>4</td><td>当 i%p==0 时，说明 p 是 i 的最小质因子。</td></tr><tr><td>5</td><td>那 i*p 也一定以 p 为最小质因子；更大的质数乘它都是重复。</td></tr><tr><td>6</td><td>所以我们停下。</td></tr></tbody></table></div><p>这就是为什么“<strong>这么做</strong>”是正确的。</p><hr><h2 id="🎯-一句话记死："><a href="#🎯-一句话记死：" class="headerlink" title="🎯 一句话记死："></a>🎯 一句话记死：</h2><blockquote><p>“因为 i 是被从小到大遍历的，所以当 i%p==0 时，p 一定是 i 的最小质因子。<br> 所以 i*p 的最小质因子也是 p。<br> 因此它只该被 p 这一轮标记一次，之后全跳过。”</p></blockquote><hr><h2 id="💡-对比图（简化）："><a href="#💡-对比图（简化）：" class="headerlink" title="💡 对比图（简化）："></a>💡 对比图（简化）：</h2><div class="table-container"><table><thead><tr><th>数</th><th>最小质因子</th><th>谁标的</th></tr></thead><tbody><tr><td>4</td><td>2</td><td>2×2</td></tr><tr><td>6</td><td>2</td><td>3×2</td></tr><tr><td>9</td><td>3</td><td>3×3</td></tr><tr><td>10</td><td>2</td><td>5×2</td></tr><tr><td>15</td><td>3</td><td>5×3</td></tr><tr><td>25</td><td>5</td><td>5×5</td></tr></tbody></table></div><p>每个合数，只出现一次标记，完美。</p><hr><p>你现在的感觉可能是：“哦——它不是魔法，是逻辑顺序决定的！”<br> 没错。线性筛看起来像“有技巧”，其实它只是精确地利用了：</p><blockquote><p>“从小到大遍历 + 最小质因子规律”。</p></blockquote><hr><p>要不要我帮你画出一个“6×6 的乘法表”，<br> 在上面标出哪些格子会被线性筛划掉、哪些会被跳过？<br> 那张表一看就能直观理解“为什么停得刚刚好”。</p><h5 id="您说：-1"><a href="#您说：-1" class="headerlink" title="您说："></a>您说：</h5><p>为什么因为 6%2==0 → 停</p><h6 id="ChatGPT-说：-1"><a href="#ChatGPT-说：-1" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>这句“因为 6%2==0 → 停”，是整个<strong>线性筛的灵魂</strong>，但第一次看到确实容易懵。<br> 别怕，我们不讲数学名词，就用生活比喻让你一秒懂。</p><hr><h2 id="🎯-我们先说结论："><a href="#🎯-我们先说结论：" class="headerlink" title="🎯 我们先说结论："></a>🎯 我们先说结论：</h2><blockquote><p>当 <code>i % p == 0</code>，说明 <strong>p 已经是 i 的最小质因子</strong>，<br> 所以任何比 p 更大的质数再去乘 i，得到的结果都会“被多次标记”，<br> 我们要及时“刹车”。</p></blockquote><hr><h2 id="🧩-用现实比喻理解："><a href="#🧩-用现实比喻理解：" class="headerlink" title="🧩 用现实比喻理解："></a>🧩 用现实比喻理解：</h2><p>想象你在工厂贴标签。</p><ul><li>每个数代表一个产品编号。</li><li>每个素数代表一个“质检员”。</li><li>合数的工作是：要被它的<strong>第一个能整除它的质检员</strong>打上“非合格”标签。</li></ul><p>工厂规定：</p><blockquote><p>任何产品只允许被最小质检员打一次标签，别重复浪费时间。</p></blockquote><hr><p>现在你是检查员，轮到你在看 <code>i = 6</code> 这件产品。</p><p>你的质检员名单是 <code>[2, 3, 5, 7...]</code>。</p><p>开始干活：</p><ol><li>第一个质检员 2 来检查：<ul><li>6%2==0 → “哦，这件产品（6）能被我整除，所以我是它的最小质因子。”</li><li>于是他打上标签，并负责它的“后代产品”：<code>6*2=12</code>。</li><li>打完后，他喊：“后面的人别来了，这活我干完了。”</li><li>所以你 <code>break</code> 停止循环。</li></ul></li><li>如果你不停止，后面的质检员（3、5、7）还会来：<ul><li>3 会再标 18</li><li>5 会再标 30</li><li>但这些数的最小质因子都是 2，本该在 2 那一轮就被标过。</li><li>所以他们做的都是重复劳动。</li></ul></li></ol><hr><h2 id="🧮-换成数学语言："><a href="#🧮-换成数学语言：" class="headerlink" title="🧮 换成数学语言："></a>🧮 换成数学语言：</h2><p>当我们在循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; count; j++) &#123;</span><br><span class="line">    int p = primes[j];</span><br><span class="line">    if (i * p &gt; N) break;</span><br><span class="line">    is_comp[i * p] = 1;</span><br><span class="line">    if (i % p == 0) break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的意思就是：</p><ul><li>对每个 i，我们拿质数 p 去生成新数 i*p。</li><li>但一旦 <code>i</code> 能被 <code>p</code> 整除：<ul><li>那说明 p 是 i 的最小质因子。</li><li>那 i*p 的最小质因子也一定是 p（而不是别的质数）。</li><li>所以之后再用更大的质数 q 去乘 i（比如 i<em>q），<br> 那个结果 i</em>q 的最小质因子仍然是 p，而不是 q。<br> 它以后会在“p 那轮”被标，不归你这轮负责。</li><li>所以我们直接停下，不再继续循环。</li></ul></li></ul><hr><h2 id="🧱-举例说明（实打实的数字）："><a href="#🧱-举例说明（实打实的数字）：" class="headerlink" title="🧱 举例说明（实打实的数字）："></a>🧱 举例说明（实打实的数字）：</h2><p>i = 6，素数表 [2,3,5]</p><div class="table-container"><table><thead><tr><th>p</th><th>i*p</th><th>i%p</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>12</td><td>0</td><td>2 是 6 的最小质因子 → 停</td></tr><tr><td>3</td><td>18</td><td>（没机会执行）</td><td>本来该由 2 那轮标掉</td></tr><tr><td>5</td><td>30</td><td>（也不用标）</td><td>同上</td></tr></tbody></table></div><p>结果：12 被标一次，18、30 由别的人标，不重复。</p><hr><h2 id="💡-再看一个不会停的例子："><a href="#💡-再看一个不会停的例子：" class="headerlink" title="💡 再看一个不会停的例子："></a>💡 再看一个不会停的例子：</h2><p>i = 9，素数表 [2,3,5]</p><div class="table-container"><table><thead><tr><th>p</th><th>i*p</th><th>i%p</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>18</td><td>≠0</td><td>继续，因为 2 不是 9 的因子</td></tr><tr><td>3</td><td>27</td><td>=0</td><td>3 是 9 的最小质因子 → 停</td></tr><tr><td>5</td><td>（不执行）</td><td></td></tr></tbody></table></div><p>这样就保证了：</p><ul><li>18 被 2 标一次。</li><li>27 被 3 标一次。</li><li>没有人重复干活。</li></ul><hr><h2 id="🧩-一句话总结："><a href="#🧩-一句话总结：" class="headerlink" title="🧩 一句话总结："></a>🧩 一句话总结：</h2><blockquote><p><strong>“当 i 能被 p 整除时，p 已经是 i 的最小质因子，<br> 所以后面的质数就不该再碰 i 的倍数，<br> 否则他们会抢活干，浪费时间。”</strong></p></blockquote><hr><p>你可以把那句 <code>if (i % p == 0) break;</code> 想成工厂里的“禁止重复贴标签”按钮。<br> 按下去，就代表“这批货我负责，后面的别动”。</p><p>这，就是线性筛为什么这么做。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法类 </tag>
            
            <tag> 快筛 </tag>
            
            <tag> 标准筛 </tag>
            
            <tag> 线性筛 </tag>
            
            <tag> 求素数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcd的一些用法</title>
      <link href="/posts/ac6b0799.html"/>
      <url>/posts/ac6b0799.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="最大公因数与最小公倍数"><a href="#最大公因数与最小公倍数" class="headerlink" title="最大公因数与最小公倍数"></a>最大公因数与最小公倍数</h1><h2 id="✅-什么是欧几里得算法（辗转相除法）？"><a href="#✅-什么是欧几里得算法（辗转相除法）？" class="headerlink" title="✅ 什么是欧几里得算法（辗转相除法）？"></a>✅ 什么是欧几里得算法（辗转相除法）？</h2><p>一句话：</p><blockquote><p>就是不断用“大数 ÷ 小数”，然后把“小数”与“余数”继续来除，直到余数变成 0，那个最后的除数就是最大公因数。</p></blockquote><hr><h2 id="✅-为什么这么做是对的？（傻瓜理解逻辑）"><a href="#✅-为什么这么做是对的？（傻瓜理解逻辑）" class="headerlink" title="✅ 为什么这么做是对的？（傻瓜理解逻辑）"></a>✅ 为什么这么做是对的？（傻瓜理解逻辑）</h2><p>假设你要找两个数的最大公因数，比如 18 和 12。</p><h3 id="你可能第一想法："><a href="#你可能第一想法：" class="headerlink" title="你可能第一想法："></a>你可能第一想法：</h3><p>“我把它们俩共同的因数列出来比较一下？”</p><p>18 的因数：1 2 3 6 9 18<br> 12 的因数：1 2 3 4 6 12<br> 共同的：1 2 3 6<br> 最大：6</p><p>对！结果是6。</p><p>但欧几里得算法的做法是：</p><hr><h2 id="✅-按步骤傻瓜化演示（以-18-和-12-为例）"><a href="#✅-按步骤傻瓜化演示（以-18-和-12-为例）" class="headerlink" title="✅ 按步骤傻瓜化演示（以 18 和 12 为例）"></a>✅ 按步骤傻瓜化演示（以 18 和 12 为例）</h2><div class="table-container"><table><thead><tr><th>步骤</th><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>18 ÷ 12 = 商 1 余 6</td><td>原来18和12的“共同因数”能帮我产生这个 6</td></tr><tr><td>2</td><td>接下来把“12”和“6”继续做除法</td><td>也就是 12 ÷ 6</td></tr><tr><td>3</td><td>12 ÷ 6 = 商 2 余 0</td><td>余数为0说明整除了</td></tr><tr><td>4</td><td>最后一次 <strong>被除数</strong> 就是最大公因数</td><td>6 就是最大公因数</td></tr></tbody></table></div><p>记住一句核心口诀：</p><blockquote><p><strong>大数 ÷ 小数 = 余数</strong><br> <strong>再用小数 ÷ 余数</strong><br> <strong>循环到余数是0为止</strong><br> <strong>最后的除数 = 最大公因数</strong></p></blockquote><hr><h2 id="✅-再举一个（稍微难一点）"><a href="#✅-再举一个（稍微难一点）" class="headerlink" title="✅ 再举一个（稍微难一点）"></a>✅ 再举一个（稍微难一点）</h2><p>求 144 和 60 的最大公因数：</p><div class="table-container"><table><thead><tr><th>步骤</th><th>计算</th><th>余数</th><th>继续</th></tr></thead><tbody><tr><td>1</td><td>144 ÷ 60</td><td>24</td><td>再用 60 ÷ 24</td></tr><tr><td>2</td><td>60 ÷ 24</td><td>12</td><td>再用 24 ÷ 12</td></tr><tr><td>3</td><td>24 ÷ 12</td><td>0</td><td>余数为0</td></tr><tr><td>结束</td><td>最大公因数 = 12</td><td></td></tr></tbody></table></div><p>所以 gcd(144, 60) = <strong>12</strong></p><hr><h2 id="✅-为什么“余数”还能继续当“测量尺”？"><a href="#✅-为什么“余数”还能继续当“测量尺”？" class="headerlink" title="✅ 为什么“余数”还能继续当“测量尺”？"></a>✅ 为什么“余数”还能继续当“测量尺”？</h2><p>可以这样理解：</p><p>你是在找一个能把两个数都整除的“最大尺子”。<br> 第一次除法把“大尺子测不准的部分”（多出来的）变成了“余数”，<br> 后面继续用“更精准的尺子”（余数）去替代原本的小的那个数。</p><p>不断“削小尺子”，直到它完全贴合。<br> 贴合时就是最大公因数。</p><hr><h2 id="✅-用一句最通俗的话总结"><a href="#✅-用一句最通俗的话总结" class="headerlink" title="✅ 用一句最通俗的话总结"></a>✅ 用一句最通俗的话总结</h2><blockquote><p><strong>不断用更小的尺子去量两个数，直到刚好不剩丁点，这个尺子就是最大公因数</strong></p><blockquote><p>[!NOTE]</p><p>公式:gcd(a, b) = gcd(b, a % b)</p></blockquote></blockquote><h1 id="最小公倍数求法"><a href="#最小公倍数求法" class="headerlink" title="最小公倍数求法"></a>最小公倍数求法</h1><h2 id="✅-但是列倍数太慢，所以有了一个超级快的公式"><a href="#✅-但是列倍数太慢，所以有了一个超级快的公式" class="headerlink" title="✅ 但是列倍数太慢，所以有了一个超级快的公式"></a>✅ 但是列倍数太慢，所以有了一个超级快的公式</h2><p>数学上有个结论（可靠且可以证明）：</p><blockquote><p><strong>两个数的乘积 = 最大公因数 × 最小公倍数</strong></p></blockquote><p>所以推出来：</p><blockquote><p><strong>最小公倍数 = (a × b) ÷ 最大公因数</strong></p></blockquote><p>这个公式就是最常用的方法。</p><hr><h1 id="✅-举个例子"><a href="#✅-举个例子" class="headerlink" title="✅ 举个例子"></a>✅ 举个例子</h1><p>求 12 和 18 的最小公倍数</p><ol><li>先求最大公因数<br> gcd(12, 18) = 6  （辗转相除法能算出来）</li><li>用公式<br> lcm = (12 × 18) ÷ 6<br> = 216 ÷ 6<br> = 36</li></ol><p>所以 <strong>最小公倍数 = 36</strong></p><hr><h1 id="✅-为什么乘积除以-gcd-就对了？（傻瓜解释）"><a href="#✅-为什么乘积除以-gcd-就对了？（傻瓜解释）" class="headerlink" title="✅ 为什么乘积除以 gcd 就对了？（傻瓜解释）"></a>✅ 为什么乘积除以 gcd 就对了？（傻瓜解释）</h1><p>因为：</p><div class="table-container"><table><thead><tr><th>项目</th><th>理解方式</th></tr></thead><tbody><tr><td>乘积</td><td>把两个数的所有因子都堆上去了（重复了一部分）</td></tr><tr><td>gcd</td><td>是那部分“重复”的公共身份</td></tr><tr><td>除 gcd</td><td>就把“重复部分”扣掉，只剩下最刚好的倍数</td></tr></tbody></table></div><hr><h1 id="✅-最通俗一句话"><a href="#✅-最通俗一句话" class="headerlink" title="✅ 最通俗一句话"></a>✅ 最通俗一句话</h1><blockquote><p><strong>最小公倍数就是：两个数的乘积，把重复分母（最大公因数）扣掉后的结果。</strong></p></blockquote><hr><p>如果你现在理解了原理，下一步我可以给你写最小公倍数的 C 语言代码，并且逐行教你怎么写、为什么这么写。</p><h1 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 题目绍介:</span></span><br><span class="line"><span class="comment">就是说输入两个数 然后生成最大公因数和最小公倍数罢了 很简单只是拿来当例子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//快读</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fastRead</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快写</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fastWrite</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">9</span>)</span><br><span class="line">        fastWrite(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;<span class="keyword">return</span> m%n==<span class="number">0</span>?n:gcd(n,m%n);&#125;<span class="comment">//这个就是那个最大公因数 用了递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> gcd)</span> &#123;<span class="keyword">return</span> (n*m)/gcd;&#125;<span class="comment">//最小公倍数的公式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> m=fastRead(),n=fastRead();</span><br><span class="line">    <span class="type">int</span> res = gcd(m,n);</span><br><span class="line">    fastWrite(res);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    fastWrite(lcm(m,n,res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法类 </tag>
            
            <tag> gcd </tag>
            
            <tag> 最大公因数 </tag>
            
            <tag> 最小公倍数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"mymod233","short_name":"mymod","start_url":"/","display":"standalone","background_color":"#1e1e2e","theme_color":"#1e1e2e","icons":[{"src":"/images/icons/icon-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/images/icons/icon-512x512.png","sizes":"512x512","type":"image/png"}]}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/offline.html"/>
      <url>/offline.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!doctype html><html lang="zh-CN"><head>  <meta charset="utf-8">  <title>离线模式 | mymod233</title>  <meta name="viewport" content="width=device-width, initial-scale=1">  <meta name="theme-color" content="#1e1e2e">  <style>    :root { --bg:#1e1e2e; --fg:#e5e7eb; --muted:#9aa4b2; --accent1:#3b82f6; --accent2:#a855f7; }    html,body{height:100%}    body{      margin:0; background: radial-gradient(1200px 800px at 20% 10%, rgba(59,130,246,.15), transparent 60%),                 radial-gradient(1000px 700px at 80% 90%, rgba(168,85,247,.12), transparent 60%),                 var(--bg);      color:var(--fg); font:16px/1.6 system-ui,-apple-system,"Segoe UI",Roboto,Inter,"Helvetica Neue",Arial;      display:flex; align-items:center; justify-content:center; padding:24px;    }    .card{width:min(720px,90vw); background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.06);      border-radius:20px; padding:28px 28px 22px; box-shadow:0 10px 30px rgba(0,0,0,.35); backdrop-filter: blur(6px);}    .logo{width:84px;height:84px;border-radius:24px;background:      linear-gradient(135deg, rgba(59,130,246,.9), rgba(168,85,247,.9));      display:flex;align-items:center;justify-content:center;margin-bottom:14px; box-shadow:0 8px 24px rgba(99,102,241,.35);}    .logo span{font-weight:800;font-size:52px;color:white;letter-spacing:.5px}    h1{margin:0 0 6px 0;font-size:26px;font-weight:800}    p{margin:6px 0;color:var(--muted)}    .actions{margin-top:18px;display:flex;gap:10px;flex-wrap:wrap}    .btn{appearance:none;border:none;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer}    .primary{background:linear-gradient(135deg, #3b82f6, #a855f7); color:#fff}    .ghost{background:transparent; color:#cbd5e1; border:1px solid rgba(255,255,255,.15)}    .tips{margin-top:10px;font-size:13px;color:#b3bdc9}    code{background:rgba(255,255,255,.06);padding:2px 6px;border-radius:6px}  </style></head><body>  <main class="card" role="main" aria-label="离线提示">    <div class="logo"><span>M</span></div>    <h1>你现在处于离线状态</h1>    <p>网络连接不可用。已缓存的页面和静态资源仍可访问。恢复网络后会自动回到最新内容。</p>    <div class="actions">      <button class="btn primary" onclick="location.reload()">重试连接</button>      <button class="btn ghost" onclick="history.back()">返回上一页</button>    </div>    <p class="tips">提示：当你再次联网后，浏览器会自动更新缓存。如果仍旧显示旧内容，按 <code>Ctrl/Cmd + F5</code> 强刷。</p>  </main></body></html>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/sw.js"/>
      <url>/sw.js</url>
      
        <content type="html"><![CDATA[/* sw.js — mymod233 进阶版 PWA   功能：静态资源 Cache First、页面 Network First、离线 fallback、更新提醒*/const CACHE_VERSION = 'v3';              // ← 每次改动SW时+1，强制让用户拿到新版本const RUNTIME_CACHE = `pwa-mymod-${CACHE_VERSION}`;const STATIC_PATTERN = /\.(?:js|css|png|jpg|jpeg|gif|svg|woff2?)$/i;const OFFLINE_URL = '/offline.html';// 安装：预缓存离线页（不要预缓存一大堆，Hexo 更新频繁）self.addEventListener('install', event => {  event.waitUntil(    caches.open(RUNTIME_CACHE).then(cache => cache.addAll([OFFLINE_URL])).then(() => self.skipWaiting())  );});// 激活：清理旧缓存，接管页面self.addEventListener('activate', event => {  event.waitUntil(    caches.keys().then(keys =>      Promise.all(keys.filter(k => k !== RUNTIME_CACHE).map(k => caches.delete(k)))    ).then(() => self.clients.claim())  );});// 获取：静态资源 Cache First，页面 Network First + 离线兜底self.addEventListener('fetch', event => {  const req = event.request;  if (req.method !== 'GET') return;  const url = new URL(req.url);  // 静态资源：缓存优先  if (STATIC_PATTERN.test(url.pathname)) {    event.respondWith(      caches.open(RUNTIME_CACHE).then(cache =>        cache.match(req).then(hit => {          const fromNet = fetch(req).then(res => {            if (res.ok) cache.put(req, res.clone());            return res;          }).catch(() => hit);          return hit || fromNet;        })      )    );    return;  }  // 页面：网络优先，失败用缓存，再失败给离线页  if (req.mode === 'navigate' || (req.headers.get('accept') || '').includes('text/html')) {    event.respondWith(      fetch(req).then(res => {        const clone = res.clone();        caches.open(RUNTIME_CACHE).then(c => c.put(req, clone));        return res;      }).catch(async () => {        const cached = await caches.match(req);        return cached || caches.match(OFFLINE_URL);      })    );    return;  }  // 其他 GET：尽量走网络，失败尝试缓存  event.respondWith(    fetch(req).catch(() => caches.match(req))  );});// 接收页面消息：允许页面请求立即激活新SWself.addEventListener('message', event => {  if (!event.data) return;  if (event.data === 'SKIP_WAITING') {    self.skipWaiting();  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p class='p center logo large'>个人介绍</p><p class='p center small'>A Wonderful Theme for Hexo</p><h2 id="大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！-⁠-⁠≧⁠Д⁠≦⁠"><a href="#大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！-⁠-⁠≧⁠Д⁠≦⁠" class="headerlink" title="大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！(⁠ ⁠≧⁠Д⁠≦⁠)"></a>大家好哦欢迎大家光临我的网站啦啦啦啦啦！！！(⁠ ⁠≧⁠Д⁠≦⁠)</h2><p>本人也就只是懂<strong>一点点</strong>电脑技术罢了 并不是那种比较会的哦 什么<strong>GitHub</strong>那些也都是最近才弄的啦！(⁠╯⁠︵⁠╰⁠,⁠)</p><p>本人的<strong>兴趣爱好</strong>都比较多啦 最喜欢的就是<strong>听音乐</strong> (<psw>猜猜我喜欢听什么www</psw>)其次才是弄<strong>电脑</strong> 体育的话喜欢<strong>棒球</strong>和<strong>职业摔角</strong>(<del>这么小众的爱好应该没有人喜欢</del>) 但是最喜欢的运动还是<strong>职业摔角</strong>啦 当然最了解的也是职业摔角www（我可是5岁看摔角看到现在的呢！(⁠ ⁠；⁠∀⁠；⁠)）</p><p>我大学的专业是<strong>计算机科学与技术</strong> 因为我想<strong>逃避算法</strong>www(<emp>事实证明我是错的呜呜呜</emp>) 我初中就是打<strong>算法竞赛</strong>的 给我弄的长脑子了</p><p>我听音乐的话主要是我小时候<strong>学架子鼓</strong> 因此对音乐都是<strong>非常敏感</strong>的 小<strong>时候还被老师夸过说我很有天赋欸嘿嘿</strong>(<del>真的很自豪的说</del>) 所以说我<strong>听音乐也是很广泛</strong>的 中文的话比较喜欢<strong>中文说唱 主要是旋律说唱emo说唱二次元说唱之类的</strong> 因为听这些其实对于我来说<strong>像是找共鸣 因为他们的歌词很直白也很贴近生活嘛 正是因为门槛低所以我就很喜欢</strong> 日语的歌的话倒是流行的都听 因为日本那边的音乐都是挺好的嘛 <strong>至于欧美的话我就偏向于neo-soul啊R&amp;B之类</strong>(<del>又小众了起来嘤嘤</del>)的 我很喜欢爵士还有neo-soul 类似的风格 因为很独特很舒服 这一类的歌就不在意歌词了 如果是听中文说唱对于我来说那就是旋律+歌词和那种意识是我最喜欢的啦</p><p>说到这里推荐几位歌手啦!(<del>当然是中文说唱的www</del>)<br><div class="tag link"><a class="link-card" title="MISTERK" href="https://music.163.com/#/artist?id=12256230"><div class="left"><img src="/img/link.png"/></div><div class="right"><p class="text">MISTERK</p><p class="url">https://music.163.com/#/artist?id=12256230</p></div></a></div></p><h2 id="这位是真的非常非常喜欢啦-二次原说唱是最屌的"><a href="#这位是真的非常非常喜欢啦-二次原说唱是最屌的" class="headerlink" title="这位是真的非常非常喜欢啦 二次原说唱是最屌的!!!()"></a>这位是真的非常非常喜欢啦 二次原说唱是最屌的!!!(<del>不接受任何反驳</del>)</h2><div class="tag link"><a class="link-card" title="河南说唱之神" href="https://music.163.com/#/artist?id=15194340"><div class="left"><img src="/img/link.png"/></div><div class="right"><p class="text">河南说唱之神</p><p class="url">https://music.163.com/#/artist?id=15194340</p></div></a></div><h2 id="忧郁之神啦-母庸置疑的"><a href="#忧郁之神啦-母庸置疑的" class="headerlink" title="忧郁之神啦!!!母庸置疑的"></a>忧郁之神啦!!!母庸置疑的</h2><div class="tag link"><a class="link-card" title="BOBBYNOPACE" href="https://music.163.com/#/artist?id=48277407"><div class="left"><img src="/img/link.png"/></div><div class="right"><p class="text">BOBBYNOPACE</p><p class="url">https://music.163.com/#/artist?id=48277407</p></div></a></div><h2 id=""><a href="#" class="headerlink" title=""></a><del>永远的佐助</del></h2><h2 id="总而言之-最喜欢大家啦"><a href="#总而言之-最喜欢大家啦" class="headerlink" title="总而言之 最喜欢大家啦!!!"></a>总而言之 最喜欢大家啦!!!</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/force-dark-pages.js"/>
      <url>/js/force-dark-pages.js</url>
      
        <content type="html"><![CDATA[;(function () {  // 需要强制暗色的路径规则，自行补充  var forceDark = /^\/(page|about|links|music)(\/|$)/i.test(location.pathname);  if (!forceDark) return;  // 1) 立刻设为 dark  try { localStorage.setItem('theme', 'dark'); } catch (e) {}  var html = document.documentElement;  html.setAttribute('data-theme', 'dark');  html.classList.add('force-dark-page');  // 2) 隐藏可能存在的主题切换按钮（多写几种常见选择器以防主题版本差异）  var hideSwitch = function () {    var selectors = [      '#toggle-mode', '.toggle-mode', '.toggle-theme', '.darkmode-switch',      '.mode', '.site-nav .mode', '.navbar .mode'    ];    selectors.forEach(function (sel) {      document.querySelectorAll(sel).forEach(function (el) {        el.style.setProperty('display', 'none', 'important');        el.setAttribute('aria-hidden', 'true');      });    });  };  hideSwitch();  // 3) 监听 data-theme，防止被外部脚本改回 light  var obs = new MutationObserver(function (muts) {    if (html.getAttribute('data-theme') !== 'dark') {      html.setAttribute('data-theme', 'dark');    }    hideSwitch();  });  obs.observe(html, { attributes: true, attributeFilter: ['data-theme'] });  // 4) 某些主题用 prefers-color-scheme，直接硬顶一层样式变量  var css = document.createElement('style');  css.textContent =    'html.force-dark-page{color-scheme: dark !important;}';  document.head.appendChild(css);})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 一张全站壁纸：滚动也不换场景 */html,body{height:100%}body{  background-image:url('/images/icons/wall.jpg');  background-size:cover;  background-position:center center;  background-repeat:no-repeat;  background-attachment:fixed;}/* 封面就是“文字层”：把封面自己的底图和大遮罩关掉 */.cover, .cover .cover-img, .cover .bg{  background:transparent !important;  background-image:none !important;}.cover .mask, .cover .cover-mask{  background: rgba(0,0,0,0.15) !important; /* 想更通透就再小点或直接透明 */}/* 封面高度铺满一屏，像你给的样例一样 */.cover{height:100vh !important}/* 下面整块布局别再铺白底，全部透下去 */#page, #body-wrap, .layout, .main-inner, #content-inner, #recent-posts, .aside-content{  background:transparent !important;}/* 卡片半透明 + 轻磨砂，保证读得清 */.card, .card-widget, .recent-posts .recent-post-item, .post-block, .post-content,.timeline, .category-list, .tag-cloud, .pagination .page-number, .pagination .extend{  background: rgba(255,255,255,0.82) !important;  backdrop-filter: blur(10px) saturate(180%);  -webkit-backdrop-filter: blur(10px) saturate(180%);}/* 夜间模式下的卡片透明度 */[data-theme="dark"] .card, [data-theme="dark"] .card-widget,[data-theme="dark"] .recent-posts .recent-post-item, [data-theme="dark"] .post-block,[data-theme="dark"] .post-content, [data-theme="dark"] .timeline,[data-theme="dark"] .category-list, [data-theme="dark"] .tag-cloud,[data-theme="dark"] .pagination .page-number, [data-theme="dark"] .pagination .extend{  background: rgba(0,0,0,0.42) !important;}/* 顶栏也做成悬浮透明（需要的话） */#nav{background:transparent !important; box-shadow:none !important}#nav .menus_items .menus_item:hover{background:rgba(0,0,0,0.08)}[data-theme="dark"] #nav .menus_items .menus_item:hover{background:rgba(255,255,255,0.08)}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>message</title>
      <link href="/message/index.html"/>
      <url>/message/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><!DOCTYPE html><html><head>  <meta charset="utf-8">  <title>Music</title>  <meta name="viewport" content="width=device-width, initial-scale=1" />  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">  <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>  <style>    body { margin: 0; padding: 2rem; font-family: system-ui, sans-serif; }    .wrap { max-width: 960px; margin: 0 auto; }  </style></head><body>  <div class="wrap">    <h1>My Playlist</h1>    <!-- 页内可见列表播放器 -->    <meting-js      server="netease"      type="playlist"      id="14437180364"      fixed="false"      autoplay="false"      order="random"      loop="all"      list-folded="false"      list-max-height="420"      preload="auto">    </meting-js>  </div>]]></content>
      
    </entry>
    
    
  
</search>
